<!doctype html><html lang=en><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="ie=edge"><title>A Crash Course in Distributed Pub-Sub Messaging With Apache Pulsar - Pulsar Neighborhood</title><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="Messaging is essential to modern life and how you get things done. So, without messaging, how would the world look? This question may appear far-fetched, but it’s a significant concern for computing. How do you talk to software? What is the mechanism through which software programs communicate with each other? How does software speak to you?"><meta property="og:title" content="A Crash Course in Distributed Pub-Sub Messaging With Apache Pulsar - Pulsar Neighborhood"><meta property="og:type" content="article"><meta property="og:url" content="https://www.pulsar-neighborhood.io/articles/a-crash-course-in-distributed-pub-sub-messaging-with-apache-pulsar/"><meta property="og:image" content="https://user-images.githubusercontent.com/16946028/180450100-9eb03dd5-6258-43cf-bd97-8222f786358b.png"><meta property="og:description" content="Messaging is essential to modern life and how you get things done. So, without messaging, how would the world look? This question may appear far-fetched, but it’s a significant concern for computing. How do you talk to software? What is the mechanism through which software programs communicate with each other? How does software speak to you?"><meta name=twitter:site content="@pulsar_neighbor"><meta name=twitter:creator content="@pulsar_neighbor"><link rel=alternate type=application/rss+xml href=/index.xml title="Site Title"><meta name=google-site-verification content="m-1Z-0k0EvG9PD7R24pKuETSaBpEvqoXgOYT-0MtuPU"><link rel=icon href=https://www.pulsar-neighborhood.io/favicon.png><link rel=canonical href=https://www.pulsar-neighborhood.io/articles/a-crash-course-in-distributed-pub-sub-messaging-with-apache-pulsar/><link rel=stylesheet href=/css/style.32ad96ee983b063b549f59db931afb8f0db25424bf2d687e1122748a7d183f73.css><style>.ctct-form-defaults{padding:15px!important}</style><script type=application/ld+json>[{"@context":"http://schema.org","@type":"WebPage","name":"Pulsar Neighborhood - A Crash Course in Distributed Pub-Sub Messaging With Apache Pulsar","description":"Messaging is essential to modern life and how you get things done. So, without messaging, how would the world look? This question may appear far-fetched, but it’s a significant concern for computing. How do you talk to software? What is the mechanism through which software programs communicate with each other? How does software speak to you?","publisher":{"@type":"Organization","name":"Pulsar Neighborhood"}},{"@context":"http://schema.org","@type":"BlogPosting","image":"https://user-images.githubusercontent.com/16946028/180450100-9eb03dd5-6258-43cf-bd97-8222f786358b.png","url":"https:\/\/www.pulsar-neighborhood.io\/articles\/a-crash-course-in-distributed-pub-sub-messaging-with-apache-pulsar\/","publisher":"Pulsar Neighborhood","headline":"A Crash Course in Distributed Pub-Sub Messaging With Apache Pulsar","dateCreated":"2022-07-22 09:36:56 -0400 -0400","datePublished":"2022-07-22 09:36:56 -0400 -0400","dateModified":"2022-07-22 09:36:56 -0400 -0400","inLanguage":"en-US","isFamilyFriendly":"true","copyrightYear":"2022","copyrightHolder":"","author":{"@type":"Person","name":"Pulsar Neighborhood","url":"https://www.pulsar-neighborhood.io"},"mainEntityOfPage":"True","articleSection":["getting-started, moving-to-pulsar"],"articleBody":"\u003cp\u003eMessaging is essential to modern life and how you get things done. So, without messaging, how would the world look? This question may appear far-fetched, but it’s a significant concern for computing. How do you talk to software? What is the mechanism through which software programs communicate with each other? How does software speak to you?\u003c\/p\u003e\n\u003cp\u003eHere’s where the role of messaging software comes into play. Software engineers despise repeatedly addressing the same issue because it consumes a lot of time, introduces inconsistencies and compatibility issues, and complicates trying to expand systems. Similarly, developers want a simple way to connect to a messaging system so they can focus on the quality of their code. Developers must resolve labor and time-intensive problems that require communication between multiple services and frequent data processing.\u003c\/p\u003e\n\u003cp\u003eSome solutions can make some of these complexities easier to manage. One of them is a message broker. A message broker is an intermediary between software entities that want to interact. It helps transmit messages from one application to another.\u003c\/p\u003e\n\u003cp\u003e\u003cimg src=\u0022https:\/\/user-images.githubusercontent.com\/16946028\/180449782-9695f71a-f206-42eb-b40f-143d499dbddf.png\u0022 alt=\u0022image1\u0022\u003e\u003c\/p\u003e\n\u003cp\u003eThe essential components of a message broker are the following:\u003c\/p\u003e\n\u003cul\u003e\n\u003cli\u003eProducer is the component responsible for sending messages. It’s directly connected to the message broker. In the pub-sub pattern, they’re publishers.\u003c\/li\u003e\n\u003cli\u003eConsumer is the component that represents the service that consumes messages in the message broker. They’re subscribers in the pub-sub design.\u003c\/li\u003e\n\u003cli\u003eQueue is like a folder in a file system. It’s a data type that message brokers use to store messages. Queues retain messages until a consuming service processes them.\u003c\/li\u003e\n\u003cli\u003eTopics are channels for transmitting messages from producers to consumers. A topic serves as an entity for categorizing messages belonging to the same technical context.\u003c\/li\u003e\n\u003c\/ul\u003e\n\u003cp\u003eMessage brokers support different forms of communication, each of which defines how it shares information between producers and consumers. The most prevalent forms of communication are the following:\u003c\/p\u003e\n\u003cul\u003e\n\u003cli\u003ePoint-to-point (queues)\u003c\/li\u003e\n\u003cli\u003ePublish and subscribe (topics)\u003c\/li\u003e\n\u003c\/ul\u003e\n\u003ch3 id=\u0022point-to-point-queues\u0022\u003ePoint-to-Point (Queues)\u003c\/h3\u003e\n\u003cp\u003eIn point-to-point communication, producers and consumers exchange messages through a destination called a queue. Producers send messages to a queue while consumers retrieve the messages from the queue.\u003c\/p\u003e\n\u003cp\u003ePoint-to-point communication is one-to-one contact between a producer and a consumer. The fact that only one consumer can consume a message distinguishes point-to-point messaging from other forms of communication.\u003c\/p\u003e\n\u003cp\u003eWhen the broker sends a message, but no consumers are available, it places the message in a queue to deliver later. However, when there are many consumers, it provides the message only once.\u003c\/p\u003e\n\u003ch3 id=\u0022publish-and-subscribe\u0022\u003ePublish and Subscribe\u003c\/h3\u003e\n\u003cp\u003eThe publish-subscribe communication model is also called the pub-sub design. Here, the producer is known as a publisher, while the consumer is known as the subscriber.\u003c\/p\u003e\n\u003cp\u003eThe pub-sub model mainly consists of the following components:\u003c\/p\u003e\n\u003cul\u003e\n\u003cli\u003eA publisher who sends out messages to a message broker.\u003c\/li\u003e\n\u003cli\u003eA subscriber who serves as a recipient of the messages from the message broker.\u003c\/li\u003e\n\u003c\/ul\u003e\n\u003cp\u003e\u003cimg src=\u0022https:\/\/user-images.githubusercontent.com\/16946028\/180449840-42120760-e7c7-4f58-9e78-091e8e8fbe46.jpg\u0022 alt=\u0022image2\u0022\u003e\u003c\/p\u003e\n\u003cp\u003eWith the pub-sub pattern, publishers don’t deliver messages to specific subscribers. Instead, message recipients subscribe to the topics that interest them. Every time a message related to that topic is pushed, all subscribers receive it immediately. There’s very little queuing or batching required. As such, pub-sub is well-suited to systems that must exchange data between multiple entities regularly.\u003c\/p\u003e\n\u003cp\u003ePublishers don’t know which subscribers or topics they subscribe to, and subscribers receive messages of interest without knowing the publishers. They communicate independently. The asynchronous nature of the pub-sub pattern allows for loose coupling and scalability, making it ideal for distributed applications, server-less, and microservices architectures. In contrast to point-to-point communication, messages registered on the topic go to multiple subscribers who have requested delivery for that topic.\u003c\/p\u003e\n\u003cp\u003e\u003cimg src=\u0022https:\/\/user-images.githubusercontent.com\/16946028\/180449867-65060b58-1e93-40a4-984c-325b70471d0e.png\u0022 alt=\u0022image3\u0022\u003e\u003c\/p\u003e\n\u003ch2 id=\u0022publish-and-subscribe-pub-sub-messaging-with-pulsar\u0022\u003ePublish and Subscribe (Pub-Sub) Messaging with Pulsar\u003c\/h2\u003e\n\u003cp\u003eApache Pulsar is a distributed, open-source messaging and cloud-native streaming platform. It’s one example of a tool you can use for pub-sub and messaging.\u003c\/p\u003e\n\u003cp\u003eUnlike most other pub-sub models, Pulsar separates producers and consumers. Pulsar acts as an intermediary that receives information from producers and sends it to consumers. Its architecture decouples message processing, serving, and storage, which resolves the shortcomings of existing open-source messaging systems, including multi-tenancy, geo-replication, and robust durability guarantees.\u003c\/p\u003e\n\u003ch3 id=\u0022protocol\u0022\u003eProtocol\u003c\/h3\u003e\n\u003cp\u003ePulsar uses a custom binary communication protocol between producers, consumers, and brokers. The protocol supports required features, such as acknowledgements and \u003ccode\u003eFlow\u003c\/code\u003e control, while ensuring maximum transport and implementation efficiency.\u003c\/p\u003e\n\u003cp\u003eClients and brokers exchange commands which use binary protocol buffer (protobuf) messages. The PulsarApi.proto file specifies the format of protobuf commands. You can arrange commands for different producers and consumers in alternate layers and send them through the same connection without restriction.\u003c\/p\u003e\n\u003cp\u003eSince protobuf doesn’t provide a message frame, the Pulsar protocol prepends all messages with a 4-byte field specifying the frame size. The maximum size of a frame is 5 MB.\u003c\/p\u003e\n\u003cp\u003eThe Pulsar protocol uses two types of commands:\u003c\/p\u003e\n\u003cul\u003e\n\u003cli\u003eSimple commands without a message.\u003c\/li\u003e\n\u003cli\u003ePayload commands with messages for publication or delivery. Payload commands send messages in a raw format outside the protobuf. The protobuf command data precedes the protobuf metadata and the payload.\u003c\/li\u003e\n\u003c\/ul\u003e\n\u003ch3 id=\u0022messages\u0022\u003eMessages\u003c\/h3\u003e\n\u003cp\u003eMessage payloads are in raw format rather than protobuf format, increasing efficiency. A BaseCommand protobuf message contains all commands in Pulsar’s protocol, and this message includes an enum type with all possible subcommands as optional fields. BaseCommand messages can specify only one subcommand.\u003c\/p\u003e\n\u003cp\u003ePulsar places broker entry metadata alongside the message metadata as a serialized protobuf message. The broker creates the metadata when the message arrives at the broker. It would pass it without changes to the consumer if you configured it to do so.\u003c\/p\u003e\n\u003cp\u003eMessage metadata is in the application-specified payload as a serialized protobuf message. The producer creates the metadata and passes it without changes to the consumer.\u003c\/p\u003e\n\u003cp\u003eWhen using batch messages, the payload contains a list of entries, each with its metadata, defined by the SingleMessageMetadata object. When compression is enabled, it compresses the whole batch at once.\u003c\/p\u003e\n\u003cp\u003eTo prevent interrupting the TCP connection, a mechanism probes for the availability status of the remote peer. This identifies prolonged network partitions between clients and brokers or cases in which a machine crashes caused by a power outage, kernel panic, or hard reboot, for example.\u003c\/p\u003e\n\u003cp\u003eBoth clients and brokers send Ping commands periodically and close the socket if they don’t receive a Pong response within a timeout period.\u003c\/p\u003e\n\u003cp\u003eProper implementation of a Pulsar client isn’t required to send the Ping probe. However, it’s necessary to promptly reply after receiving one from the broker to prevent the remote side from closing the TCP connection.\u003c\/p\u003e\n\u003ch3 id=\u0022producers\u0022\u003eProducers\u003c\/h3\u003e\n\u003cp\u003eTo send messages, a client must establish a producer. When creating a producer, the broker first verifies that a client is authorized to publish on the topic.\u003c\/p\u003e\n\u003cp\u003eOnce the client confirms the producer’s creation, it can post messages to the broker, referring to the producer ID negotiated before.\u003c\/p\u003e\n\u003cp\u003eSuppose the client doesn’t receive a response indicating producer creation success or failure. In that case, the client sends a command to close the original producer before sending a command to re-attempt producer creation.\u003c\/p\u003e\n\u003ch3 id=\u0022consumers\u0022\u003eConsumers\u003c\/h3\u003e\n\u003cp\u003eA consumer attaches to a subscription and consumes messages from it. After every reconnection, a client must subscribe to the topic. After the consumer is ready, the client must permit the broker to push messages using the \u003ccode\u003eFlow\u003c\/code\u003e command. A \u003ccode\u003eFlow\u003c\/code\u003e command gives additional permission to send messages to the consumer. A typical consumer implementation uses a queue to accumulate these messages before the application is ready to consume them.\u003c\/p\u003e\n\u003cp\u003eAfter the application dequeues half the messages in the line, the consumer sends permits to the broker to ask for more. It asks for an amount equal to half of the messages in the queue. For example, if the queue size is 5000 and the consumer consumes 1000 messages in the line, the consumer sends permits to the broker asking for 2000 messages.\u003c\/p\u003e\n\u003ch2 id=\u0022common-use-cases-of-pub-sub\u0022\u003eCommon Use Cases of Pub-Sub\u003c\/h2\u003e\n\u003cp\u003eThe publish-subscribe messaging pattern forms the foundation of Apache Pulsar. In this model, publishers send messages to topics, consumers subscribe to those topics, consumers receive messages from subscribed topics, and finally, consumers send acknowledgements to the message broker when processing is complete. All these interactions occur through Apache Pulsar.\u003c\/p\u003e\n\u003cp\u003e\u003cimg src=\u0022https:\/\/user-images.githubusercontent.com\/16946028\/180449946-947e41dc-6771-448a-95f5-ee97c4cd42e0.png\u0022 alt=\u0022image5\u0022\u003e\u003c\/p\u003e\n\u003cp\u003eThe looseness of pub-sub messaging and a streaming platform like Pulsar is a powerful solution for various engineering problems. It also makes Pulsar an excellent choice for large-scale distributed architectures. Let’s examine a few use cases of how you might use pub-sub messaging to resolve some real-world challenges.\u003c\/p\u003e\n\u003cp\u003eThe looseness of pub-sub messaging and a streaming platform like Pulsar is a powerful solution for various engineering problems. It also makes Pulsar an excellent choice for large-scale distributed architectures. Let’s examine a few use cases of how you might use pub-sub messaging to resolve some real-world challenges.\u003c\/p\u003e\n\u003ch3 id=\u0022event-notification\u0022\u003eEvent Notification\u003c\/h3\u003e\n\u003cp\u003ePulsar is well-suited to handling event notifications because it can send events simultaneously to many recipients. Sending simultaneous events is a common technical challenge. You need a system that can quickly deliver events to consumers without causing adverse effects when the number of destinations grows exponentially. Depending on the architecture, consumers may not always be accessible online, but when they come back online, they must receive the messages they missed.\u003c\/p\u003e\n\u003cp\u003eMoreover, some messages might need additional processing before they can be consumed. Because of pub-sub’s loose coupling, publishers can send events without concern about which consumers are online. Traditionally, this would require an architecture where one component would support pub-sub for messaging and a separate component would handle message queuing. Pulsar is unique in that it effortlessly supports both within a single platform.\u003c\/p\u003e\n\u003ch3 id=\u0022distributed-logging\u0022\u003eDistributed Logging\u003c\/h3\u003e\n\u003cp\u003eMessaging platforms, including Pulsar, keep application logs. These logs are an essential component of distributed systems. Companies can use logs as a low-cost tool for reconstructing events, triggering alerts as they occur, and keeping track of significant transactions.\u003c\/p\u003e\n\u003cp\u003eYou can simultaneously send logs to multiple subscribed destinations using Pulsar. You can also create explicit logging channels or instruct message recipients to log events in numerous destinations.\u003c\/p\u003e\n\u003ch3 id=\u0022multi-tenancy-to-support-different-teams\u0022\u003eMulti-Tenancy to Support Different Teams\u003c\/h3\u003e\n\u003cp\u003eOnce you have a high-performance, scalable messaging system, you’ll want to share it with other teams within your organization. Multi-tenancy means that different user groups can use the same resources. Apache Pulsar can limit the resources different tenants in different namespaces can use. One can specify the maximum number of producers and consumers and the maximum quantity of storage each consumer can have.\u003c\/p\u003e\n\u003ch2 id=\u0022why-developers-prefer-pub-sub\u0022\u003eWhy Developers Prefer Pub-Sub\u003c\/h2\u003e\n\u003cp\u003eDevelopers like pub-sub messaging for several reasons. Let’s look at some.\u003c\/p\u003e\n\u003ch3 id=\u0022it-eliminates-polling\u0022\u003eIt Eliminates Polling\u003c\/h3\u003e\n\u003cp\u003eThe pub-sub messaging pattern offers significant benefits to application developers who build applications that depend on real-time events. Message topics enable instant, push-based delivery, so consumers don’t have to check for updates or “poll” for new information.\u003c\/p\u003e\n\u003cp\u003ePush-based delivery expedites response time and reduces delivery latency, which can be especially problematic in systems where delays are intolerable.\u003c\/p\u003e\n\u003ch3 id=\u0022it-decouples-and-scales-independently\u0022\u003eIt Decouples and Scales Independently\u003c\/h3\u003e\n\u003cp\u003ePub-sub generally increases the flexibility of software. Publishers and subscribers can operate independently. Independence lets you grow and scale each one on its own. The producers do not need to know anything about the consumers in advance. Pulsar simplifies communication by providing a reliable intra-component channel that decouples the message senders from the receivers.\u003c\/p\u003e\n\u003cp\u003eAdditionally, Pulsar lets different layers in an application’s architecture scale independently and infinitely. The message serving layer will not be affected if the message storage layer requires additional storage. This is contrary to traditional data processing technologies where data serving and storage are located on the same node, which makes it challenging to scale.\u003c\/p\u003e\n\u003ch2 id=\u0022conclusion\u0022\u003eConclusion\u003c\/h2\u003e\n\u003cp\u003ePub-Sub Messaging simplifies communication, enabling you to build real-time, event-driven applications that improve performance, reliability, and scalability. Apache Pulsar is the core engine for many enterprise-grade messaging solutions. It unifies pub-sub messaging and streaming into a single platform and provides infinite scalability, multi-tenancy, zero data loss, geo-replication, and encryption.\u003c\/p\u003e\n\u003cp\u003eModern-day cloud-native applications use Pulsar to decouple storage and serving layers into independent modules that are convenient to develop, deploy, and scale. Pub-sub messaging enables event-driven architectures and asynchronous parallel processing, making it the most efficient and effective messaging model for systems requiring real-time communication.\u003c\/p\u003e\n"}]</script></head><body class='page bg-secondary'><div id=main-menu-mobile class=main-menu-mobile><ul></ul></div><div class=wrapper><div class='header sticky-top bg-secondary'><div class=container><div class=logo><a href=https://www.pulsar-neighborhood.io><img src=/svg/Pulsar-Neighborhood-Logo.svg class=img-fluid></a></div><div class=logo-mobile><a href=https://www.pulsar-neighborhood.io><img src=/svg/Neighborhood-Icon.svg class=img-fluid></a></div><div id=main-menu class=main-menu><ul><li><a href=/about><span>About The Pulsar Neighborhood</span></a></li><li><a href=https://pulsar.apache.org/ target=_blank><span>About Apache Pulsar</span></a></li><li><a href=https://pulsar.apache.org/docs/en/standalone/ target=_blank><span></span>Project Documentation</span></a></li><li><a href=/index.xml><img src=/svg/square-rss-solid.svg title="Subscribe to The Pulsar Neighborhood feed" class=img-fluid style=height:30px></a></li></ul></div><button id=toggle-main-menu-mobile class="hamburger hamburger--slider" type=button>
<span class=hamburger-box><span class=hamburger-inner></span></span></button></div></div><div class="container pt-2 pb-3"><div class=row><div class="col-0 col-md-2"><div class=sidebar><div class=mb-2><a href=/guides/getting-started><div class="col-12 btn btn-success">Get Started with Pulsar</div></a></div><div class="spotlight mb-2 border border-primary rounded"><div class="row bg-primary no-gutters"><div class="col-12 text-secondary p-1">&nbsp;Find Topics</div></div><div class=p-1><div class="row no-gutters"><div class="col-12 mb-1"><h4>Category</h4><ul><li>&nbsp;<a class=text-decoration-none href=/categories/at-the-edge>At the Edge</a> [3]</li><li>&nbsp;<a class=text-decoration-none href=/categories/cluster-administration>Cluster Administration</a> [3]</li><li>&nbsp;<a class=text-decoration-none href=/categories/getting-started>Getting Started</a> [15]</li><li>&nbsp;<a class=text-decoration-none href=/categories/machine-learning>Machine Learning</a> [2]</li><li>&nbsp;<a class=text-decoration-none href=/categories/moving-to-pulsar>Moving to Pulsar</a> [10]</li><li>&nbsp;<a class=text-decoration-none href=/categories/pulsar-architecture>Pulsar Architecture</a> [10]</li><li>&nbsp;<a class=text-decoration-none href=/categories/pulsar-components>Pulsar Components</a> [8]</li><li>&nbsp;<a class=text-decoration-none href=/categories/use-cases>Use Cases</a> [4]</li></ul></div><div class=col-12><h4>View All</h4><div class="mt-1 pb-1"><a href=/articles>Articles</a>
&nbsp;|&nbsp;<a href=/guides>Guides</a>
&nbsp;|&nbsp;<a href=/videos>Videos</a></div></div></div></div></div></div></div><div class="col-12 col-md-8"><div class=container><header class=mb-3><div class=pb-2><img src=https://user-images.githubusercontent.com/16946028/180450100-9eb03dd5-6258-43cf-bd97-8222f786358b.png alt="A Crash Course in Distributed Pub-Sub Messaging With Apache Pulsar" class=img-fluid style=max-width:85%;max-height:200px></div><h1>A Crash Course in Distributed Pub-Sub Messaging With Apache Pulsar</h1><div class="row no-gutters"><div class="col col-auto mr-1">Categories:</div><div class="col col-auto"><a class=text-decoration-none href=/categories/getting-started>Getting Started</a>,&nbsp;</div><div class="col col-auto"><a class=text-decoration-none href=/categories/moving-to-pulsar>Moving to Pulsar</a></div></div></header><div class="row mb-3 no-gutters border-top border-bottom"><div class=col-2><ul class="list-group list-group-horizontal mt-1 mb-1"><li class="list-group-item flex-fill border-0 p-0 mr-3"><a href="https://www.linkedin.com/sharing/share-offsite/?mini=true&url=https%3a%2f%2fwww.pulsar-neighborhood.io%2farticles%2fa-crash-course-in-distributed-pub-sub-messaging-with-apache-pulsar%2f&title=A%20Crash%20Course%20in%20Distributed%20Pub-Sub%20Messaging%20With%20Apache%20Pulsar" target=_blank><img src=/svg/linkedin-in-brands.svg title="Share this on LinkedIn" class=img-fluid></a></li><li class="list-group-item flex-fill border-0 p-0 mr-3"><a target=_blank href="https://twitter.com/intent/tweet?text=A%20Crash%20Course%20in%20Distributed%20Pub-Sub%20Messaging%20With%20Apache%20Pulsar&url=https%3a%2f%2fwww.pulsar-neighborhood.io%2farticles%2fa-crash-course-in-distributed-pub-sub-messaging-with-apache-pulsar%2f&hashtags=apachepulsar&via=pulsar_neighbor"><img src=/svg/twitter-brands.svg title="Share this on Twitter" class=img-fluid></a></li></ul></div><div class="col text-right"><span class=text-muted>Author:</span> Pulsar Neighborhood<br><span class=text-muted>Published:</span> July 22, 2022</div></div><article><p>Messaging is essential to modern life and how you get things done. So, without messaging, how would the world look? This question may appear far-fetched, but it’s a significant concern for computing. How do you talk to software? What is the mechanism through which software programs communicate with each other? How does software speak to you?</p><p>Here’s where the role of messaging software comes into play. Software engineers despise repeatedly addressing the same issue because it consumes a lot of time, introduces inconsistencies and compatibility issues, and complicates trying to expand systems. Similarly, developers want a simple way to connect to a messaging system so they can focus on the quality of their code. Developers must resolve labor and time-intensive problems that require communication between multiple services and frequent data processing.</p><p>Some solutions can make some of these complexities easier to manage. One of them is a message broker. A message broker is an intermediary between software entities that want to interact. It helps transmit messages from one application to another.</p><p><img src=https://user-images.githubusercontent.com/16946028/180449782-9695f71a-f206-42eb-b40f-143d499dbddf.png alt=image1></p><p>The essential components of a message broker are the following:</p><ul><li>Producer is the component responsible for sending messages. It’s directly connected to the message broker. In the pub-sub pattern, they’re publishers.</li><li>Consumer is the component that represents the service that consumes messages in the message broker. They’re subscribers in the pub-sub design.</li><li>Queue is like a folder in a file system. It’s a data type that message brokers use to store messages. Queues retain messages until a consuming service processes them.</li><li>Topics are channels for transmitting messages from producers to consumers. A topic serves as an entity for categorizing messages belonging to the same technical context.</li></ul><p>Message brokers support different forms of communication, each of which defines how it shares information between producers and consumers. The most prevalent forms of communication are the following:</p><ul><li>Point-to-point (queues)</li><li>Publish and subscribe (topics)</li></ul><h3 id=point-to-point-queues>Point-to-Point (Queues)</h3><p>In point-to-point communication, producers and consumers exchange messages through a destination called a queue. Producers send messages to a queue while consumers retrieve the messages from the queue.</p><p>Point-to-point communication is one-to-one contact between a producer and a consumer. The fact that only one consumer can consume a message distinguishes point-to-point messaging from other forms of communication.</p><p>When the broker sends a message, but no consumers are available, it places the message in a queue to deliver later. However, when there are many consumers, it provides the message only once.</p><h3 id=publish-and-subscribe>Publish and Subscribe</h3><p>The publish-subscribe communication model is also called the pub-sub design. Here, the producer is known as a publisher, while the consumer is known as the subscriber.</p><p>The pub-sub model mainly consists of the following components:</p><ul><li>A publisher who sends out messages to a message broker.</li><li>A subscriber who serves as a recipient of the messages from the message broker.</li></ul><p><img src=https://user-images.githubusercontent.com/16946028/180449840-42120760-e7c7-4f58-9e78-091e8e8fbe46.jpg alt=image2></p><p>With the pub-sub pattern, publishers don’t deliver messages to specific subscribers. Instead, message recipients subscribe to the topics that interest them. Every time a message related to that topic is pushed, all subscribers receive it immediately. There’s very little queuing or batching required. As such, pub-sub is well-suited to systems that must exchange data between multiple entities regularly.</p><p>Publishers don’t know which subscribers or topics they subscribe to, and subscribers receive messages of interest without knowing the publishers. They communicate independently. The asynchronous nature of the pub-sub pattern allows for loose coupling and scalability, making it ideal for distributed applications, server-less, and microservices architectures. In contrast to point-to-point communication, messages registered on the topic go to multiple subscribers who have requested delivery for that topic.</p><p><img src=https://user-images.githubusercontent.com/16946028/180449867-65060b58-1e93-40a4-984c-325b70471d0e.png alt=image3></p><h2 id=publish-and-subscribe-pub-sub-messaging-with-pulsar>Publish and Subscribe (Pub-Sub) Messaging with Pulsar</h2><p>Apache Pulsar is a distributed, open-source messaging and cloud-native streaming platform. It’s one example of a tool you can use for pub-sub and messaging.</p><p>Unlike most other pub-sub models, Pulsar separates producers and consumers. Pulsar acts as an intermediary that receives information from producers and sends it to consumers. Its architecture decouples message processing, serving, and storage, which resolves the shortcomings of existing open-source messaging systems, including multi-tenancy, geo-replication, and robust durability guarantees.</p><h3 id=protocol>Protocol</h3><p>Pulsar uses a custom binary communication protocol between producers, consumers, and brokers. The protocol supports required features, such as acknowledgements and <code>Flow</code> control, while ensuring maximum transport and implementation efficiency.</p><p>Clients and brokers exchange commands which use binary protocol buffer (protobuf) messages. The PulsarApi.proto file specifies the format of protobuf commands. You can arrange commands for different producers and consumers in alternate layers and send them through the same connection without restriction.</p><p>Since protobuf doesn’t provide a message frame, the Pulsar protocol prepends all messages with a 4-byte field specifying the frame size. The maximum size of a frame is 5 MB.</p><p>The Pulsar protocol uses two types of commands:</p><ul><li>Simple commands without a message.</li><li>Payload commands with messages for publication or delivery. Payload commands send messages in a raw format outside the protobuf. The protobuf command data precedes the protobuf metadata and the payload.</li></ul><h3 id=messages>Messages</h3><p>Message payloads are in raw format rather than protobuf format, increasing efficiency. A BaseCommand protobuf message contains all commands in Pulsar’s protocol, and this message includes an enum type with all possible subcommands as optional fields. BaseCommand messages can specify only one subcommand.</p><p>Pulsar places broker entry metadata alongside the message metadata as a serialized protobuf message. The broker creates the metadata when the message arrives at the broker. It would pass it without changes to the consumer if you configured it to do so.</p><p>Message metadata is in the application-specified payload as a serialized protobuf message. The producer creates the metadata and passes it without changes to the consumer.</p><p>When using batch messages, the payload contains a list of entries, each with its metadata, defined by the SingleMessageMetadata object. When compression is enabled, it compresses the whole batch at once.</p><p>To prevent interrupting the TCP connection, a mechanism probes for the availability status of the remote peer. This identifies prolonged network partitions between clients and brokers or cases in which a machine crashes caused by a power outage, kernel panic, or hard reboot, for example.</p><p>Both clients and brokers send Ping commands periodically and close the socket if they don’t receive a Pong response within a timeout period.</p><p>Proper implementation of a Pulsar client isn’t required to send the Ping probe. However, it’s necessary to promptly reply after receiving one from the broker to prevent the remote side from closing the TCP connection.</p><h3 id=producers>Producers</h3><p>To send messages, a client must establish a producer. When creating a producer, the broker first verifies that a client is authorized to publish on the topic.</p><p>Once the client confirms the producer’s creation, it can post messages to the broker, referring to the producer ID negotiated before.</p><p>Suppose the client doesn’t receive a response indicating producer creation success or failure. In that case, the client sends a command to close the original producer before sending a command to re-attempt producer creation.</p><h3 id=consumers>Consumers</h3><p>A consumer attaches to a subscription and consumes messages from it. After every reconnection, a client must subscribe to the topic. After the consumer is ready, the client must permit the broker to push messages using the <code>Flow</code> command. A <code>Flow</code> command gives additional permission to send messages to the consumer. A typical consumer implementation uses a queue to accumulate these messages before the application is ready to consume them.</p><p>After the application dequeues half the messages in the line, the consumer sends permits to the broker to ask for more. It asks for an amount equal to half of the messages in the queue. For example, if the queue size is 5000 and the consumer consumes 1000 messages in the line, the consumer sends permits to the broker asking for 2000 messages.</p><h2 id=common-use-cases-of-pub-sub>Common Use Cases of Pub-Sub</h2><p>The publish-subscribe messaging pattern forms the foundation of Apache Pulsar. In this model, publishers send messages to topics, consumers subscribe to those topics, consumers receive messages from subscribed topics, and finally, consumers send acknowledgements to the message broker when processing is complete. All these interactions occur through Apache Pulsar.</p><p><img src=https://user-images.githubusercontent.com/16946028/180449946-947e41dc-6771-448a-95f5-ee97c4cd42e0.png alt=image5></p><p>The looseness of pub-sub messaging and a streaming platform like Pulsar is a powerful solution for various engineering problems. It also makes Pulsar an excellent choice for large-scale distributed architectures. Let’s examine a few use cases of how you might use pub-sub messaging to resolve some real-world challenges.</p><p>The looseness of pub-sub messaging and a streaming platform like Pulsar is a powerful solution for various engineering problems. It also makes Pulsar an excellent choice for large-scale distributed architectures. Let’s examine a few use cases of how you might use pub-sub messaging to resolve some real-world challenges.</p><h3 id=event-notification>Event Notification</h3><p>Pulsar is well-suited to handling event notifications because it can send events simultaneously to many recipients. Sending simultaneous events is a common technical challenge. You need a system that can quickly deliver events to consumers without causing adverse effects when the number of destinations grows exponentially. Depending on the architecture, consumers may not always be accessible online, but when they come back online, they must receive the messages they missed.</p><p>Moreover, some messages might need additional processing before they can be consumed. Because of pub-sub’s loose coupling, publishers can send events without concern about which consumers are online. Traditionally, this would require an architecture where one component would support pub-sub for messaging and a separate component would handle message queuing. Pulsar is unique in that it effortlessly supports both within a single platform.</p><h3 id=distributed-logging>Distributed Logging</h3><p>Messaging platforms, including Pulsar, keep application logs. These logs are an essential component of distributed systems. Companies can use logs as a low-cost tool for reconstructing events, triggering alerts as they occur, and keeping track of significant transactions.</p><p>You can simultaneously send logs to multiple subscribed destinations using Pulsar. You can also create explicit logging channels or instruct message recipients to log events in numerous destinations.</p><h3 id=multi-tenancy-to-support-different-teams>Multi-Tenancy to Support Different Teams</h3><p>Once you have a high-performance, scalable messaging system, you’ll want to share it with other teams within your organization. Multi-tenancy means that different user groups can use the same resources. Apache Pulsar can limit the resources different tenants in different namespaces can use. One can specify the maximum number of producers and consumers and the maximum quantity of storage each consumer can have.</p><h2 id=why-developers-prefer-pub-sub>Why Developers Prefer Pub-Sub</h2><p>Developers like pub-sub messaging for several reasons. Let’s look at some.</p><h3 id=it-eliminates-polling>It Eliminates Polling</h3><p>The pub-sub messaging pattern offers significant benefits to application developers who build applications that depend on real-time events. Message topics enable instant, push-based delivery, so consumers don’t have to check for updates or “poll” for new information.</p><p>Push-based delivery expedites response time and reduces delivery latency, which can be especially problematic in systems where delays are intolerable.</p><h3 id=it-decouples-and-scales-independently>It Decouples and Scales Independently</h3><p>Pub-sub generally increases the flexibility of software. Publishers and subscribers can operate independently. Independence lets you grow and scale each one on its own. The producers do not need to know anything about the consumers in advance. Pulsar simplifies communication by providing a reliable intra-component channel that decouples the message senders from the receivers.</p><p>Additionally, Pulsar lets different layers in an application’s architecture scale independently and infinitely. The message serving layer will not be affected if the message storage layer requires additional storage. This is contrary to traditional data processing technologies where data serving and storage are located on the same node, which makes it challenging to scale.</p><h2 id=conclusion>Conclusion</h2><p>Pub-Sub Messaging simplifies communication, enabling you to build real-time, event-driven applications that improve performance, reliability, and scalability. Apache Pulsar is the core engine for many enterprise-grade messaging solutions. It unifies pub-sub messaging and streaming into a single platform and provides infinite scalability, multi-tenancy, zero data loss, geo-replication, and encryption.</p><p>Modern-day cloud-native applications use Pulsar to decouple storage and serving layers into independent modules that are convenient to develop, deploy, and scale. Pub-sub messaging enables event-driven architectures and asynchronous parallel processing, making it the most efficient and effective messaging model for systems requiring real-time communication.</p></article><div class="row border border-primary rounded"><div class="col p-2"><h3>You might also like...</h3><div class=row><div class="col text-center p-2"><div><a href=/articles/rest-versus-event-driven-architecture-why-it-s-time-to-switch-from-request-based-architecture/><img src=https://user-images.githubusercontent.com/16946028/175393332-fbd80156-a0a1-4f96-84a2-56d01e6bc16e.png alt class=img-fluid style=max-width:150px></a></div><div class=pt-2><a href=/articles/rest-versus-event-driven-architecture-why-it-s-time-to-switch-from-request-based-architecture/>REST Versus Event Driven Architecture - Why It's Time to Switch From Request Based Architecture</a></div><div class=pt-2>This article introduces REST and event-driven architectures and explains why organizations should …</div></div><div class="col text-center p-2"><div><a href=/articles/why-managed-apache-pulsar-is-the-right-choice/><img src=https://user-images.githubusercontent.com/16946028/175392736-555608d6-d5cb-426a-b41a-7b2babadff9c.png alt class=img-fluid style=max-width:150px></a></div><div class=pt-2><a href=/articles/why-managed-apache-pulsar-is-the-right-choice/>Why Managed Apache Pulsar Is the Right Choice</a></div><div class=pt-2>In this article, we’ll explore why and how using a managed Apache Pulsar service saves you time and …</div></div><div class="col text-center p-2"><div><a href=/articles/do-i-have-time-to-learn-event-streaming/><img src=https://user-images.githubusercontent.com/16946028/168359869-21a4d6b6-b761-43c9-8b1d-2a5d3ee2f83c.png alt class=img-fluid style=max-width:150px></a></div><div class=pt-2><a href=/articles/do-i-have-time-to-learn-event-streaming/>Do I Have Time to Learn Event Streaming?</a></div><div class=pt-2>In this article, we’ll explore what event streaming is, how it works, and discuss the growing …</div></div></div></div></div><br><div id=disqus_thread></div><script type=text/javascript>(function(){if(window.location.hostname=="localhost")return;var t,e=document.createElement("script");e.type="text/javascript",e.async=!0,t="pulsar-neighborhood",e.src="//"+t+".disqus.com/embed.js",(document.getElementsByTagName("head")[0]||document.getElementsByTagName("body")[0]).appendChild(e)})()</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript></div></div><div class="col-0 col-md-2"><nav class="navbar navbar-light mb-3"><div class=row><div class=col-12><h4>In this article</h4></div><div class="col-12 border-left border-primary pr-0"><nav id=TableOfContents><ul><li><ul><li><a href=#point-to-point-queues>Point-to-Point (Queues)</a></li><li><a href=#publish-and-subscribe>Publish and Subscribe</a></li></ul></li><li><a href=#publish-and-subscribe-pub-sub-messaging-with-pulsar>Publish and Subscribe (Pub-Sub) Messaging with Pulsar</a><ul><li><a href=#protocol>Protocol</a></li><li><a href=#messages>Messages</a></li><li><a href=#producers>Producers</a></li><li><a href=#consumers>Consumers</a></li></ul></li><li><a href=#common-use-cases-of-pub-sub>Common Use Cases of Pub-Sub</a><ul><li><a href=#event-notification>Event Notification</a></li><li><a href=#distributed-logging>Distributed Logging</a></li><li><a href=#multi-tenancy-to-support-different-teams>Multi-Tenancy to Support Different Teams</a></li></ul></li><li><a href=#why-developers-prefer-pub-sub>Why Developers Prefer Pub-Sub</a><ul><li><a href=#it-eliminates-polling>It Eliminates Polling</a></li><li><a href=#it-decouples-and-scales-independently>It Decouples and Scales Independently</a></li></ul></li><li><a href=#conclusion>Conclusion</a></li></ul></nav></div></div></nav></div></div></div></div><div class="sub-footer m-5"><div class=row><div class="col-12 text-center"><a href=https://github.com/pulsar-neighborhood/pulsar-neighborhood.github.io/blob/main/content/articles/A-Crash-Course-in-Distributed-Pub-Sub-Messaging-with-Apache-Pulsar.md target=_blank>Improve this page</a></div></div><div class="col-8 offset-2"><hr class="bg-primary text-primary"></div><div class="sub-footer-inner mt-2"><div><div class=mb-1>Pulsar Neighborhood</div><div><ul><li style=width:40px><a href=https://github.com/pulsar-neighborhood target=_blank><img src=/svg/github-brands.svg title="Pulsar Neighborhood on GitHub" class=img-fluid></a></li><li class="ml-3 mr-1" style=width:40px><a href=https://twitter.com/pulsar_neighbor target=_blank><img src=/svg/twitter-brands.svg title="Pulsar Neighborhood on Twitter" class=img-fluid></a></li><li style=width:40px><a href=https://www.youtube.com/c/ApachePulsarNeighborhood target=_blank><img src=/svg/youtube-brands.svg title="Pulsar Neighborhood on YouTube" class=img-fluid></a></li><li style=width:40px><a href=https://datastudio.google.com/reporting/743d9f31-c80f-4e60-b520-730631d3c250 target=_blank><img src=/png/google-analytics.png title="Pulsar Neighborhood analytics" class=img-fluid></a></li></ul></div></div><div class=p-5></div><div><div class=mb-1>Apache Pulsar</div><div><ul><li style=width:40px><a href=https://pulsar.apache.org target=_blank><img src=/png/pulsar-icon.jpg title="Apache Pulsar project home" class=img-fluid></a></li><li class="ml-3 mr-1" style=width:40px><a href=https://github.com/apache-pulsar target=_blank><img src=/svg/github-brands.svg title="Apache Pulsar on GitHub" class=img-fluid></a></li><li class=mr-1 style=width:40px><a href=https://twitter.com/Apache_Pulsar target=_blank><img src=/svg/twitter-brands.svg title="Apache Pulsar on Twitter" class=img-fluid></a></li><li class=mr-1 style=width:30px><a href=https://stackoverflow.com/questions/tagged/apache-pulsar target=_blank><img src=/svg/stack-overflow-brands.svg title="Apache Pulsar on Stackoverflow" class=img-fluid></a></li><li style=width:40px><a href=https://apache-pulsar.slack.com target=_blank><img src=/svg/slack-brands.svg title="Apache Pulsar slack channel" class=img-fluid></a></li></ul></div></div></div><div class="row text-center mb-3"><div class=col-12><a class="btn btn-info" href=https://pulsar.apache.org/community/ target=_blank>Join the Pulsar community</a></div></div><div class="row text-center"><div class="col-12 text-center"><div><a href=https://github.com/pulsar-neighborhood/pulsar-neighborhood.github.io/issues/new/choose>Contact Us</a></div></div></div></div><script type=text/javascript src=/js/scripts.min.8efe3e711319c2d0a300a084134e3f3bedcb60dce21f1e0ef12767f654242b44.js></script>
<script src=https://ajax.googleapis.com/ajax/libs/jquery/3.6.0/jquery.min.js></script>
<script src=https://cdn.jsdelivr.net/npm/bootstrap@4.6.1/dist/js/bootstrap.bundle.min.js integrity=sha384-fQybjgWLrvvRgtW6bFlB7jaZrFsaBXjsOMm/tB9LTS58ONXgqbR9W8oWht/amnpF crossorigin=anonymous></script>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-8S9SD43SBH"></script>
<script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-8S9SD43SBH")</script></body></html>
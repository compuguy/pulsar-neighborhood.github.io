<!doctype html><html lang=en><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="ie=edge"><title>How Pulsar and Kafka Partitions Work (And How They Differ) - Pulsar Neighborhood</title><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="The Pulsar Neighborhood community enables Apache Pulsar users and developers to learn about Pulsar and how to use it in their professional lives; via useful, interactive content (including blogs, Meetups, and YouTube videos). This is all driven by a passionate, vendor neutral, and inclusive community of members."><meta property="og:title" content="The Pulsar Neighborhood"><meta property="og:type" content="article"><meta property="og:url" content="https://www.pulsar-neighborhood.io"><meta property="og:image" content="https://www.pulsar-neighborhood.io/png/blue-logotype.png"><meta property="og:description" content="The Pulsar Neighborhood community enables Apache Pulsar users and developers to learn about Pulsar and how to use it in their professional lives; via useful, interactive content (including blogs, Meetups, and YouTube videos). This is all driven by a passionate, vendor neutral, and inclusive community of members."><meta name=twitter:site content="@pulsar_neighbor"><meta name=twitter:creator content="@pulsar_neighbor"><link rel=alternate type=application/rss+xml href=/index.xml title="Site Title"><meta name=google-site-verification content="m-1Z-0k0EvG9PD7R24pKuETSaBpEvqoXgOYT-0MtuPU"><link rel=icon href=https://www.pulsar-neighborhood.io/favicon.png><link rel=canonical href=https://www.pulsar-neighborhood.io/articles/how-pulsar-and-kafka-partitions-work-and-how-they-differ/><link rel=stylesheet href=/css/style.32ad96ee983b063b549f59db931afb8f0db25424bf2d687e1122748a7d183f73.css><style>.ctct-form-defaults{padding:15px!important}</style><script type=application/ld+json>{"@context":"http://schema.org","@type":"BlogPosting","image":"https:\/\/user-images.githubusercontent.com\/16946028\/168374625-c69691a5-420d-4dfd-8229-d0dcf8e03934.png","url":"https:\/\/www.pulsar-neighborhood.io\/articles\/how-pulsar-and-kafka-partitions-work-and-how-they-differ\/","publisher":"Pulsar Neighborhood","headline":"How Pulsar and Kafka Partitions Work (And How They Differ)","dateCreated":"2022-05-13 15:16:04 -0400 -0400","datePublished":"2022-05-13 15:16:04 -0400 -0400","dateModified":"2022-05-13 15:16:04 -0400 -0400","inLanguage":"en-US","isFamilyFriendly":"true","copyrightYear":"2022","copyrightHolder":"","author":{"@type":"Person","name":"Pulsar Neighborhood","url":"https://www.pulsar-neighborhood.io"},"mainEntityOfPage":"True","articleSection":["pulsar-architecture, pulsar-components"],"articleBody":"\u003cp\u003eThe purpose of stream processing platforms is to enable real-time, high-throughput data processing. In addition, decoupling the system that produces the data from the system that processes it helps us meet scaling demands.\u003c\/p\u003e\n\u003cp\u003eApache Kafka (developed by LinkedIn) is one of the most popular stream processing platforms. Later, Apache Pulsar was created to improve on some of Kafka’s constraints — namely, simple scaling and \u003ca href=\u0022https:\/\/pulsar.apache.org\/docs\/en\/administration-geo\/\u0022 target=\u0022_blank\u0022\u003egeo-replication\u003c\/a\u003e.\u003c\/p\u003e\n\u003cp\u003eBoth solutions aim to increase the amount of data that can be consumed and processed by horizontal scaling — spreading data across many partitions. This is possible thanks to parallel processing, wherein the data producer writes to multiple partitions and the consumer reads them.\u003c\/p\u003e\n\u003ch2 id=\u0022pulsar-and-kafka-partitions\u0022\u003ePulsar and Kafka Partitions\u003c\/h2\u003e\n\u003cp\u003eApache Pulsar and Apache Kafka use partitions in a similar fashion. However, there are subtle differences in how the underlying technology works. First, we’ll take a look at how they work conceptually, then we’ll get into the technical differences.\u003c\/p\u003e\n\u003cp\u003eWith both technologies, data goes into a topic. A topic is effectively a stream or queue of data. These systems aim to provide scalable ways to maintain real-time data processing, even when writing large amounts of data to these topics. A topic can have multiple producers and multiple consumers. Each producer can write data to the topic and the consumers can read it. Furthermore, each consumer independently keeps track of their position in the stream to ensure they are completely decoupled. If one consumer dies, the others can continue.\u003c\/p\u003e\n\u003cp\u003eAs mentioned previously, scale is achieved with partitions. Each topic can be split into multiple partitions, which then provide multiple entry and exit points for the data. For example, assume we have a system that’s writing many messages onto a topic. With one partition, the consumer reads and processes the messages sequentially. This works at a small scale and may be desirable if the messages need to be processed sequentially.\u003c\/p\u003e\n\u003cp\u003eHowever, if the number of messages being produced outpaces the consumer, the consumer will never reach the end of the queue and latency between message production and processing will increase. The solution is to use multiple partitions which enable multiple consumers to be set up to process many messages simultaneously.\u003c\/p\u003e\n\u003cp\u003ePulsar and Kafka each combine two approaches to decide which partition a particular message should be written to: round robin and key based. Round robin — the default behavior for both — spreads the data evenly across all partitions. The producer simply adds messages to each partition one at a time until it reaches the end. Then, it goes back to the beginning and starts again. Round-robin consumers work the same way — a single consumer takes a message from each partition one at a time before returning to the beginning.\u003c\/p\u003e\n\u003cp\u003eHowever, if we want to increase throughput, we can create multiple consumers — these are called consumer groups in Kafka and \u003ca href=\u0022https:\/\/www.datastax.com\/blog\/2019\/11\/subscriptions-multiple-groups-consumers-pulsar-topic\u0022 target=\u0022_blank\u0022\u003eshared subscriptions\u003c\/a\u003e in Pulsar. In this case, each consumer is given a specific set of partitions. For example, if there were six partitions and two consumers in the consumer group or shared subscription, each consumer would be assigned three partitions. Each consumer would follow the round robin method the same way, but only across its three partitions. This only works if the application is horizontally scalable and messages can be processed simultaneously. If a particular order is needed, another approach must be taken.\u003c\/p\u003e\n\u003cp\u003eOne of these approaches is key-based partitioning, where the producer decides which partition a message should go on by using a particular key. For example, imagine we want all messages concerning a particular customer to be processed in order. We could use the customer ID as the partition key so messages are always sent to the same partition. The consumer will then process the messages in this partition sequentially, maintaining their order.\u003c\/p\u003e\n\u003cp\u003eAgain, if we had multiple consumers in the same consumer group or shared subscription, each consumer would be assigned specific partitions so the consumer would still process messages in order. The downside of this approach is the potential for partition skew. If a single customer produces 80 percent of the data, then one partition will handle 80 percent of the data — which can reduce throughput.\u003c\/p\u003e\n\u003ch3 id=\u0022key-differences\u0022\u003eKey Differences\u003c\/h3\u003e\n\u003cp\u003eThe main differences between Kafka and Pulsar relate to how they deal with resiliency. When dealing with large, time-dependent systems, it’s important to consider their resiliency if part of the system fails. For example, if one of the brokers hosting a partition dies, what happens to the data that’s been written to it? How do we continue consuming new data?\u003c\/p\u003e\n\u003cp\u003eKafka enables resiliency by replicating partitions across multiple brokers — ideally, at least three. One partition becomes the lead while the other two receive copies of the data. If the broker containing the lead partition dies, one of the other partitions is hot-swapped in and replication to the third partition will resume as soon as the third broker is re-instantiated. While this does provide resiliency, bringing the broker back up can be a slow process because data and state information are stored within the broker.\u003c\/p\u003e\n\u003cp\u003ePulsar, on the other hand, has stateless brokers. The brokers themselves don’t store any data. They simply handle incoming requests and the dispatching of data. This means that, unlike Kafka, any broker can quickly be spun up after a failure. Data in Pulsar is stored with \u003ca href=\u0022https:\/\/bookkeeper.apache.org\/\u0022 target=\u0022_blank\u0022\u003eApache BookKeeper\u003c\/a\u003e, which handles replication across multiple “bookies” (servers) and provides resiliency. If a bookie dies, then the Pulsar brokers simply start reading and writing from one of the failovers without much degradation in performance. BookKeeper handles the hard work of bringing up a new bookie.\u003c\/p\u003e\n\u003cp\u003eFinally, there are other non-partition-related benefits to Apache Pulsar — like geo-replication across multiple physical locations — which are not possible in Kafka with the paid Confluent Cloud service.\u003c\/p\u003e\n\u003ch2 id=\u0022conclusion\u0022\u003eConclusion\u003c\/h2\u003e\n\u003cp\u003eApache Kafka is a tried and tested technology that enables high throughput data systems. It uses partitions to enable scale, increasing data throughput and resiliency through replication. Apache Kafka is famous for providing high throughput over low latency.\u003c\/p\u003e\n\u003cp\u003eApache Pulsar is considered favorable for lower latency. Although it uses partitions in a similar way to Kafka, the data is stored within a separate service: Apache BookKeeper. This separation means that Pulsar brokers are faster to spin up and re-instantiate compared to Kafka, as they are stateless and do not store any data. This can be a vital difference if our system requires low latency, real-time processing. We can be sure that brokers will not be out of action for as long. Learn more about \u003ca href=\u0022https:\/\/pulsar.apache.org\/\u0022 target=\u0022_blank\u0022\u003eApache Pulsar\u003c\/a\u003e.\u003c\/p\u003e\n"}</script></head><body class='page bg-secondary'><div id=main-menu-mobile class=main-menu-mobile><ul></ul></div><div class=wrapper><div class='header sticky-top bg-secondary'><div class=container><div class=logo><a href=https://www.pulsar-neighborhood.io><img src=/svg/Pulsar-Neighborhood-Logo.svg class=img-fluid></a></div><div class=logo-mobile><a href=https://www.pulsar-neighborhood.io><img src=/svg/Neighborhood-Icon.svg class=img-fluid></a></div><div id=main-menu class=main-menu><ul><li><a href=/about><span>About The Pulsar Neighborhood</span></a></li><li><a href=https://pulsar.apache.org/ target=_blank><span>About Apache Pulsar</span></a></li><li><a href=https://pulsar.apache.org/docs/en/standalone/ target=_blank><span></span>Project Documentation</span></a></li><li><a href=/index.xml><img src=/svg/square-rss-solid.svg title="Subscribe to The Pulsar Neighborhood feed" class=img-fluid style=height:30px></a></li></ul></div><button id=toggle-main-menu-mobile class="hamburger hamburger--slider" type=button>
<span class=hamburger-box><span class=hamburger-inner></span></span></button></div></div><div class="container pt-2 pb-3"><div class=row><div class="col-0 col-md-2"><div class=sidebar><div class=mb-2><a href=/guides/getting-started><div class="col-12 btn btn-success">Get Started with Pulsar</div></a></div><div class="spotlight mb-2 border border-primary rounded"><div class="row bg-primary no-gutters"><div class="col-12 text-secondary p-1">&nbsp;Find Articles and Guides</div></div><div class=p-1><div class="row no-gutters"><div class="col-12 mb-1"><h4>Level</h4><ul><li><input class=form-check-input type=checkbox id=100 onclick=toggleFilter(filterOptions.levelFilters,this.id)><label class=form-check-label for=100>&nbsp;Beginner (100)</label></li><li><input class=form-check-input type=checkbox id=200 onclick=toggleFilter(filterOptions.levelFilters,this.id)><label class=form-check-label for=200>&nbsp;Intermediate (200)</label></li><li><input class=form-check-input type=checkbox id=300 onclick=toggleFilter(filterOptions.levelFilters,this.id)><label class=form-check-label for=300>&nbsp;Advanced (300)</label></li></ul></div><div class="row no-gutters"><div class=col-12><h4>Category</h4><ul><li><input class=form-check-input type=checkbox id=at-the-edge onclick=toggleFilter(filterOptions.categoryFilters,this.id)>
<label class=form-check-label for=at-the-edge>&nbsp;At the Edge [3]</label></li><li><input class=form-check-input type=checkbox id=cluster-administration onclick=toggleFilter(filterOptions.categoryFilters,this.id)>
<label class=form-check-label for=cluster-administration>&nbsp;Cluster Administration [2]</label></li><li><input class=form-check-input type=checkbox id=getting-started onclick=toggleFilter(filterOptions.categoryFilters,this.id)>
<label class=form-check-label for=getting-started>&nbsp;Getting Started [13]</label></li><li><input class=form-check-input type=checkbox id=machine-learning onclick=toggleFilter(filterOptions.categoryFilters,this.id)>
<label class=form-check-label for=machine-learning>&nbsp;Machine Learning [2]</label></li><li><input class=form-check-input type=checkbox id=moving-to-pulsar onclick=toggleFilter(filterOptions.categoryFilters,this.id)>
<label class=form-check-label for=moving-to-pulsar>&nbsp;Moving to Pulsar [8]</label></li><li><input class=form-check-input type=checkbox id=newsletter onclick=toggleFilter(filterOptions.categoryFilters,this.id)>
<label class=form-check-label for=newsletter>&nbsp;Newsletter [7]</label></li><li><input class=form-check-input type=checkbox id=project-news onclick=toggleFilter(filterOptions.categoryFilters,this.id)>
<label class=form-check-label for=project-news>&nbsp;Project News [3]</label></li><li><input class=form-check-input type=checkbox id=pulsar-architecture onclick=toggleFilter(filterOptions.categoryFilters,this.id)>
<label class=form-check-label for=pulsar-architecture>&nbsp;Pulsar Architecture [10]</label></li><li><input class=form-check-input type=checkbox id=pulsar-components onclick=toggleFilter(filterOptions.categoryFilters,this.id)>
<label class=form-check-label for=pulsar-components>&nbsp;Pulsar Components [6]</label></li><li><input class=form-check-input type=checkbox id=use-cases onclick=toggleFilter(filterOptions.categoryFilters,this.id)>
<label class=form-check-label for=use-cases>&nbsp;Use Cases [4]</label></li></ul></div></div></div></div></div></div></div><div class="col-12 col-md-8"><div class=container><header class=mb-3><div class=pb-2><img src=https://user-images.githubusercontent.com/16946028/168374625-c69691a5-420d-4dfd-8229-d0dcf8e03934.png alt class=img-fluid style=max-width:85%;max-height:200px></div><h1>How Pulsar and Kafka Partitions Work (And How They Differ)</h1></header><div class="row mb-3 no-gutters border-top border-bottom"><div class=col-2><ul class="list-group list-group-horizontal mt-1 mb-1"><li class="list-group-item flex-fill border-0 p-0 mr-3"><a href="https://www.linkedin.com/sharing/share-offsite/?mini=true&url=https%3a%2f%2fwww.pulsar-neighborhood.io%2farticles%2fhow-pulsar-and-kafka-partitions-work-and-how-they-differ%2f&title=How%20Pulsar%20and%20Kafka%20Partitions%20Work%20%28And%20How%20They%20Differ%29" target=_blank><img src=/svg/linkedin-in-brands.svg title="Share this on LinkedIn" class=img-fluid></a></li><li class="list-group-item flex-fill border-0 p-0 mr-3"><a target=_blank href="https://twitter.com/intent/tweet?text=How%20Pulsar%20and%20Kafka%20Partitions%20Work%20%28And%20How%20They%20Differ%29&url=https%3a%2f%2fwww.pulsar-neighborhood.io%2farticles%2fhow-pulsar-and-kafka-partitions-work-and-how-they-differ%2f&hashtags=apachepulsar&via=pulsar_neighbor"><img src=/svg/twitter-brands.svg title="Share this on Twitter" class=img-fluid></a></li></ul></div><div class="col text-right"><span class=text-muted>Author:</span> Pulsar Neighborhood<br><span class=text-muted>Published:</span> May 13, 2022</div></div><article><p>The purpose of stream processing platforms is to enable real-time, high-throughput data processing. In addition, decoupling the system that produces the data from the system that processes it helps us meet scaling demands.</p><p>Apache Kafka (developed by LinkedIn) is one of the most popular stream processing platforms. Later, Apache Pulsar was created to improve on some of Kafka’s constraints — namely, simple scaling and <a href=https://pulsar.apache.org/docs/en/administration-geo/ target=_blank>geo-replication</a>.</p><p>Both solutions aim to increase the amount of data that can be consumed and processed by horizontal scaling — spreading data across many partitions. This is possible thanks to parallel processing, wherein the data producer writes to multiple partitions and the consumer reads them.</p><h2 id=pulsar-and-kafka-partitions>Pulsar and Kafka Partitions</h2><p>Apache Pulsar and Apache Kafka use partitions in a similar fashion. However, there are subtle differences in how the underlying technology works. First, we’ll take a look at how they work conceptually, then we’ll get into the technical differences.</p><p>With both technologies, data goes into a topic. A topic is effectively a stream or queue of data. These systems aim to provide scalable ways to maintain real-time data processing, even when writing large amounts of data to these topics. A topic can have multiple producers and multiple consumers. Each producer can write data to the topic and the consumers can read it. Furthermore, each consumer independently keeps track of their position in the stream to ensure they are completely decoupled. If one consumer dies, the others can continue.</p><p>As mentioned previously, scale is achieved with partitions. Each topic can be split into multiple partitions, which then provide multiple entry and exit points for the data. For example, assume we have a system that’s writing many messages onto a topic. With one partition, the consumer reads and processes the messages sequentially. This works at a small scale and may be desirable if the messages need to be processed sequentially.</p><p>However, if the number of messages being produced outpaces the consumer, the consumer will never reach the end of the queue and latency between message production and processing will increase. The solution is to use multiple partitions which enable multiple consumers to be set up to process many messages simultaneously.</p><p>Pulsar and Kafka each combine two approaches to decide which partition a particular message should be written to: round robin and key based. Round robin — the default behavior for both — spreads the data evenly across all partitions. The producer simply adds messages to each partition one at a time until it reaches the end. Then, it goes back to the beginning and starts again. Round-robin consumers work the same way — a single consumer takes a message from each partition one at a time before returning to the beginning.</p><p>However, if we want to increase throughput, we can create multiple consumers — these are called consumer groups in Kafka and <a href=https://www.datastax.com/blog/2019/11/subscriptions-multiple-groups-consumers-pulsar-topic target=_blank>shared subscriptions</a> in Pulsar. In this case, each consumer is given a specific set of partitions. For example, if there were six partitions and two consumers in the consumer group or shared subscription, each consumer would be assigned three partitions. Each consumer would follow the round robin method the same way, but only across its three partitions. This only works if the application is horizontally scalable and messages can be processed simultaneously. If a particular order is needed, another approach must be taken.</p><p>One of these approaches is key-based partitioning, where the producer decides which partition a message should go on by using a particular key. For example, imagine we want all messages concerning a particular customer to be processed in order. We could use the customer ID as the partition key so messages are always sent to the same partition. The consumer will then process the messages in this partition sequentially, maintaining their order.</p><p>Again, if we had multiple consumers in the same consumer group or shared subscription, each consumer would be assigned specific partitions so the consumer would still process messages in order. The downside of this approach is the potential for partition skew. If a single customer produces 80 percent of the data, then one partition will handle 80 percent of the data — which can reduce throughput.</p><h3 id=key-differences>Key Differences</h3><p>The main differences between Kafka and Pulsar relate to how they deal with resiliency. When dealing with large, time-dependent systems, it’s important to consider their resiliency if part of the system fails. For example, if one of the brokers hosting a partition dies, what happens to the data that’s been written to it? How do we continue consuming new data?</p><p>Kafka enables resiliency by replicating partitions across multiple brokers — ideally, at least three. One partition becomes the lead while the other two receive copies of the data. If the broker containing the lead partition dies, one of the other partitions is hot-swapped in and replication to the third partition will resume as soon as the third broker is re-instantiated. While this does provide resiliency, bringing the broker back up can be a slow process because data and state information are stored within the broker.</p><p>Pulsar, on the other hand, has stateless brokers. The brokers themselves don’t store any data. They simply handle incoming requests and the dispatching of data. This means that, unlike Kafka, any broker can quickly be spun up after a failure. Data in Pulsar is stored with <a href=https://bookkeeper.apache.org/ target=_blank>Apache BookKeeper</a>, which handles replication across multiple “bookies” (servers) and provides resiliency. If a bookie dies, then the Pulsar brokers simply start reading and writing from one of the failovers without much degradation in performance. BookKeeper handles the hard work of bringing up a new bookie.</p><p>Finally, there are other non-partition-related benefits to Apache Pulsar — like geo-replication across multiple physical locations — which are not possible in Kafka with the paid Confluent Cloud service.</p><h2 id=conclusion>Conclusion</h2><p>Apache Kafka is a tried and tested technology that enables high throughput data systems. It uses partitions to enable scale, increasing data throughput and resiliency through replication. Apache Kafka is famous for providing high throughput over low latency.</p><p>Apache Pulsar is considered favorable for lower latency. Although it uses partitions in a similar way to Kafka, the data is stored within a separate service: Apache BookKeeper. This separation means that Pulsar brokers are faster to spin up and re-instantiate compared to Kafka, as they are stateless and do not store any data. This can be a vital difference if our system requires low latency, real-time processing. We can be sure that brokers will not be out of action for as long. Learn more about <a href=https://pulsar.apache.org/ target=_blank>Apache Pulsar</a>.</p></article><div class="row border border-primary rounded"><div class="col p-2"><h3>You might also like...</h3><div class=row><div class="col text-center p-2"><div class=pt-2><a href=/articles/apache-pulsar-deep-dive-an-end-to-end-view-of-the-data-flow/>[Video] Apache Pulsar Deep Dive an End-to-End View of the Data Flow</a></div><div class=pt-2>Enrico Olivelli gives us a tour of how data moves from the Producer to the Consumer.</div></div><div class="col text-center p-2"><div><a href=/articles/apache-pulsar-schema-versus-schemaless-whos-the-winner/><img src=https://user-images.githubusercontent.com/16946028/163627115-5ecb2834-3c8c-42ee-8ab1-1bb52f110f05.png alt class=img-fluid style=max-width:150px></a></div><div class=pt-2><a href=/articles/apache-pulsar-schema-versus-schemaless-whos-the-winner/>Apache Pulsar Schema versus Schemaless — Who’s the Winner?</a></div><div class=pt-2>In this article, we’ll examine how Pulsar Schemas work and contrast them with schemaless systems to …</div></div><div class="col text-center p-2"><div><a href=/articles/understanding-the-differences-between-message-queues-and-streaming/><img src=https://user-images.githubusercontent.com/16946028/159678986-ccaf6b62-e9ea-43c5-8901-3361f5392bfb.png alt class=img-fluid style=max-width:150px></a></div><div class=pt-2><a href=/articles/understanding-the-differences-between-message-queues-and-streaming/>Understanding the Differences Between Message Queues and Streaming</a></div><div class=pt-2>Almost any application that requires real-time or near-real-time data processing benefits from …</div></div></div></div></div><br><div id=disqus_thread></div><script type=text/javascript>(function(){if(window.location.hostname=="localhost")return;var t,e=document.createElement("script");e.type="text/javascript",e.async=!0,t="pulsar-neighborhood",e.src="//"+t+".disqus.com/embed.js",(document.getElementsByTagName("head")[0]||document.getElementsByTagName("body")[0]).appendChild(e)})()</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript></div></div><div class="col-0 col-md-2"><nav class="navbar navbar-light mb-3"><div class=row><div class=col-12><h4>In this article</h4></div><div class="col-12 border-left border-primary pr-0"><nav id=TableOfContents><ul><li><a href=#pulsar-and-kafka-partitions>Pulsar and Kafka Partitions</a><ul><li><a href=#key-differences>Key Differences</a></li></ul></li><li><a href=#conclusion>Conclusion</a></li></ul></nav></div></div></nav><div class="row border border-primary rounded no-gutters"><div class="col-12 bg-primary p-1"><div class=text-secondary>&nbsp;Join Our Newsletter</div></div><div class=col-12><div class=ctct-inline-form data-form-id=7514f5a0-b12d-44b3-93bf-e16449e783ca style=padding:0></div></div></div></div></div></div></div><div class="sub-footer m-5"><div class=row><div class="col-12 text-center"><a href=https://github.com/pulsar-neighborhood/pulsar-neighborhood.github.io/blob/main/content/articles/How-Pulsar-and-Kafka-Partitions-Work-And-How-They-Differ.md target=_blank>Improve this page</a></div></div><div class="col-8 offset-2"><hr class="bg-primary text-primary"></div><div class="sub-footer-inner mt-2"><div><div class=mb-1>Pulsar Neighborhood</div><div><ul><li style=width:40px><a href=https://github.com/pulsar-neighborhood target=_blank><img src=/svg/github-brands.svg title="Pulsar Neighborhood on GitHub" class=img-fluid></a></li><li class="ml-3 mr-1" style=width:40px><a href=https://twitter.com/pulsar_neighbor target=_blank><img src=/svg/twitter-brands.svg title="Pulsar Neighborhood on Twitter" class=img-fluid></a></li><li style=width:40px><a href=https://www.youtube.com/c/ApachePulsarNeighborhood target=_blank><img src=/svg/youtube-brands.svg title="Pulsar Neighborhood on YouTube" class=img-fluid></a></li><li style=width:40px><a href=https://datastudio.google.com/reporting/743d9f31-c80f-4e60-b520-730631d3c250 target=_blank><img src=/png/google-analytics.png title="Pulsar Neighborhood analytics" class=img-fluid></a></li></ul></div></div><div class=p-5></div><div><div class=mb-1>Apache Pulsar</div><div><ul><li style=width:40px><a href=https://pulsar.apache.org target=_blank><img src=/png/pulsar-icon.jpg title="Apache Pulsar project home" class=img-fluid></a></li><li class="ml-3 mr-1" style=width:40px><a href=https://github.com/apache-pulsar target=_blank><img src=/svg/github-brands.svg title="Apache Pulsar on GitHub" class=img-fluid></a></li><li class=mr-1 style=width:40px><a href=https://twitter.com/Apache_Pulsar target=_blank><img src=/svg/twitter-brands.svg title="Apache Pulsar on Twitter" class=img-fluid></a></li><li class=mr-1 style=width:30px><a href=https://stackoverflow.com/questions/tagged/apache-pulsar target=_blank><img src=/svg/stack-overflow-brands.svg title="Apache Pulsar on Stackoverflow" class=img-fluid></a></li><li style=width:40px><a href=https://apache-pulsar.slack.com target=_blank><img src=/svg/slack-brands.svg title="Apache Pulsar slack channel" class=img-fluid></a></li></ul></div></div></div><div class="row text-center mb-3"><div class=col-12><a class="btn btn-info" href=https://pulsar.apache.org/community/ target=_blank>Join the Pulsar community</a></div></div><div class="row text-center"><div class="col-12 text-center"><div>Privacy Policy&nbsp;&nbsp;|&nbsp;&nbsp;Terms & Condition</div></div></div></div><script type=text/javascript src=/js/scripts.min.8efe3e711319c2d0a300a084134e3f3bedcb60dce21f1e0ef12767f654242b44.js></script>
<script type=text/javascript src=/js/filter.min.2ee09abe7fb6b636d1e7cc4506185cec9d630337089eff4daf0ccc27318f376e.js></script>
<script src=https://ajax.googleapis.com/ajax/libs/jquery/3.6.0/jquery.min.js></script>
<script src=https://cdn.jsdelivr.net/npm/bootstrap@4.6.1/dist/js/bootstrap.bundle.min.js integrity=sha384-fQybjgWLrvvRgtW6bFlB7jaZrFsaBXjsOMm/tB9LTS58ONXgqbR9W8oWht/amnpF crossorigin=anonymous></script>
<script>var _ctct_m="310a7590faa964361197c4644ef1de96"</script><script id=signupScript src=//static.ctctcdn.com/js/signup-form-widget/current/signup-form-widget.min.js async defer></script>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-8S9SD43SBH"></script>
<script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-8S9SD43SBH")</script></body></html>
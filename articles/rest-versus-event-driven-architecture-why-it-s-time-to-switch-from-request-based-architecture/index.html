<!doctype html><html lang=en><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="ie=edge"><title>REST Versus Event Driven Architecture - Why It's Time to Switch From Request Based Architecture - Pulsar Neighborhood</title>
<meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="REST and event-driven architectures rule different computer systems to communicate and create reliable APIs. Read more to learn about the benefits of REST architecture."><meta property="og:title" content="REST Versus Event Driven Architecture - Why It's Time to Switch From Request Based Architecture - Pulsar Neighborhood"><meta property="og:type" content="article"><meta property="og:url" content="https://www.pulsar-neighborhood.io/articles/rest-versus-event-driven-architecture-why-it-s-time-to-switch-from-request-based-architecture/"><meta property="og:image" content="https://user-images.githubusercontent.com/16946028/175393332-fbd80156-a0a1-4f96-84a2-56d01e6bc16e.png"><meta name=description content="REST and event-driven architectures rule different computer systems to communicate and create reliable APIs. Read more to learn about the benefits of REST architecture."><meta name=twitter:site content="@pulsar_neighbor"><meta name=twitter:creator content="@pulsar_neighbor"><link rel=alternate type=application/rss+xml href=/index.xml title="Site Title"><meta name=google-site-verification content="m-1Z-0k0EvG9PD7R24pKuETSaBpEvqoXgOYT-0MtuPU"><link rel=icon href=https://www.pulsar-neighborhood.io/favicon.png><link rel=canonical href=https://www.pulsar-neighborhood.io/articles/rest-versus-event-driven-architecture-why-it-s-time-to-switch-from-request-based-architecture/><link rel=stylesheet href=/css/style.32ad96ee983b063b549f59db931afb8f0db25424bf2d687e1122748a7d183f73.css><style>.ctct-form-defaults{padding:15px!important}</style><script type=application/ld+json>[{"@context":"http://schema.org","@type":"WebPage","name":"Pulsar Neighborhood - REST Versus Event Driven Architecture - Why It\u0027s Time to Switch From Request Based Architecture","description":"REST and event-driven architectures rule different computer systems to communicate and create reliable APIs. Read more to learn about the benefits of REST architecture.","publisher":{"@type":"Organization","name":"Pulsar Neighborhood"},"keywords":["rest architecture"]},{"@context":"http://schema.org","@type":"BlogPosting","image":"https://user-images.githubusercontent.com/16946028/175393332-fbd80156-a0a1-4f96-84a2-56d01e6bc16e.png","url":"https:\/\/www.pulsar-neighborhood.io\/articles\/rest-versus-event-driven-architecture-why-it-s-time-to-switch-from-request-based-architecture\/","publisher":"Pulsar Neighborhood","headline":"REST Versus Event Driven Architecture - Why It\u0027s Time to Switch From Request Based Architecture","dateCreated":"2022-06-23 16:39:59 -0400 -0400","datePublished":"2022-06-23 16:39:59 -0400 -0400","dateModified":"2022-06-23 16:39:59 -0400 -0400","inLanguage":"en-US","isFamilyFriendly":"true","copyrightYear":"2022","copyrightHolder":"","author":{"@type":"Person","name":"Pulsar Neighborhood","url":"https://www.pulsar-neighborhood.io"},"mainEntityOfPage":"True","articleSection":["getting-started, moving-to-pulsar, use-cases"],"keywords":["rest architecture"],"articleBody":"\u003cp\u003eBuilding for an improved customer experience should be at the forefront of every organization’s mind during development. Improving engagement and customer information is one way of ensuring an enhanced customer experience.\u003c\/p\u003e\n\u003cp\u003eFor example, social media websites like Instagram and Facebook notify you when someone likes, comments, or follows you. Likewise, your favorite food vendor app tells you when your order is ready and on its way.\u003c\/p\u003e\n\u003cp\u003eAll these immediate notifications are a result of the application of event-driven architecture. Unlike representational state transfer (REST) applications that rely on a back-and-forth exchange (request and response) approach to information, event-driven architectures (EDA) respond based on specific events.\u003c\/p\u003e\n\u003cp\u003eThis article introduces REST and event-driven architectures and explains why organizations should move to an EDA to maximize customer satisfaction.\u003c\/p\u003e\n\u003ch2 id=\u0022a-look-at-rest\u0022\u003eA Look at REST\u003c\/h2\u003e\n\u003cp\u003eREST architecture follows a request and response model, where users must send requests before receiving a response. A REST service application tightly couples each microservice for execution in a pre-arranged sequence.\u003c\/p\u003e\n\u003cp\u003eREST architectures help define rules for different computer systems to communicate on the internet and create stateless and reliable APIs. The following are two fundamental guiding principles of a REST architecture:\u003c\/p\u003e\n\u003cul\u003e\n\u003cli\u003eClient and server separation\u003c\/li\u003e\n\u003cli\u003eStatelessness\u003c\/li\u003e\n\u003c\/ul\u003e\n\u003ch3 id=\u0022client-and-server-separation\u0022\u003eClient and Server Separation\u003c\/h3\u003e\n\u003cp\u003eIn REST, the separation of concerns principle implements the needs of the client and server separately. Separating the user interface needs from the server needs makes each component easy to scale and evolve independently.\u003c\/p\u003e\n\u003ch3 id=\u0022statelessness\u0022\u003eStatelessness\u003c\/h3\u003e\n\u003cp\u003eIn REST architecture, the server retains no information from a session, and the receiver understands the information in each session without needing context from previous sessions. This quality helps improve performance in high-volume operations by reducing server load.\u003c\/p\u003e\n\u003cp\u003eOther guiding principles of REST include its ability to cache information and its layered system, which helps promote system scalability.\u003c\/p\u003e\n\u003cp\u003e\u003cimg src=\u0022https:\/\/user-images.githubusercontent.com\/16946028\/175393212-e5d354a9-f2c4-4922-be7f-9e6a1c16f044.png\u0022 alt=\u0022REST architecture\u0022\u003e\u003c\/p\u003e\n\u003cp\u003eAs a request-based architecture, a single orchestrator coordinates all interactions between microservices, introducing a single failure point.\u003c\/p\u003e\n\u003cp\u003eHere are some limitations of REST:\u003c\/p\u003e\n\u003cul\u003e\n\u003cli\u003ePoor customer experience\u003c\/li\u003e\n\u003cli\u003eTightly coupled architecture introduces cascading failures\u003c\/li\u003e\n\u003cli\u003eHard to scale\u003c\/li\u003e\n\u003cli\u003eWaste of resources\u003c\/li\u003e\n\u003c\/ul\u003e\n\u003ch3 id=\u0022poor-customer-experience\u0022\u003ePoor Customer Experience\u003c\/h3\u003e\n\u003cp\u003eSince customers must send in a request for information each time, it increases the wait time for a single round trip and can be frustrating. For example, the cumulative time spent on the food vendor application is the sum of all the time spent on each microservice (inventory, stock, billing, delivery).\u003c\/p\u003e\n\u003ch3 id=\u0022tightly-coupled-architecture-introduces-cascading-failures\u0022\u003eTightly Coupled Architecture Introduces Cascading Failures\u003c\/h3\u003e\n\u003cp\u003eAs each microservice in a REST application is mainly dependent and connected, a failure in one service causes an overall system failure. Failures from the inventory service mean updates to the next microservice (billing) in the sequence never happens, which leads to cascading failure.\u003c\/p\u003e\n\u003ch3 id=\u0022hard-to-scale\u0022\u003eHard to Scale\u003c\/h3\u003e\n\u003cp\u003eDue to the large amounts of interconnected APIs, the application becomes harder to scale with multiple endpoints present.\u003c\/p\u003e\n\u003ch3 id=\u0022waste-of-resources\u0022\u003eWaste of Resources\u003c\/h3\u003e\n\u003cp\u003eAs each request follows a predefined sequence of events before fetching a response, a single action makes several unnecessary API calls to a server. This wastes resources for both the client and the server, ultimately increasing costs.\u003c\/p\u003e\n\u003ch2 id=\u0022a-look-at-eda\u0022\u003eA Look at EDA\u003c\/h2\u003e\n\u003cp\u003eUnlike REST, EDA uses an event to trigger and communicate between loosely coupled microservices. An event could be a change in a state or an update, like adding an extra item to a shopping cart or canceling a ride.\u003c\/p\u003e\n\u003cp\u003eEDA contains three key components. It includes an event producer, an event router, and an event consumer. When an event occurs, the producers publish it to the event router, filtering it and relating the information to the consumers. You can scale, update, and deploy producer and consumer services independently because they exist independently.\u003c\/p\u003e\n\u003cp\u003eOther names for EDAs include push, streaming, or asynchronous APIs. It performs two essential functions:\u003c\/p\u003e\n\u003cul\u003e\n\u003cli\u003eIt acts as a medium by which consumers subscribe to events of interest.\u003c\/li\u003e\n\u003cli\u003eIt ensures synchronous delivery of events to subscribed consumers.\u003c\/li\u003e\n\u003c\/ul\u003e\n\u003cp\u003eSome advantages of EDA are:\u003c\/p\u003e\n\u003cul\u003e\n\u003cli\u003eReduced chance of cascading failures\u003c\/li\u003e\n\u003cli\u003eReduced costs\u003c\/li\u003e\n\u003cli\u003eImproved customer experience\u003c\/li\u003e\n\u003cli\u003eEasier to scale\u003c\/li\u003e\n\u003cli\u003eAgile development\u003c\/li\u003e\n\u003c\/ul\u003e\n\u003cp\u003eLet’s take a closer look at each of these.\u003c\/p\u003e\n\u003ch3 id=\u0022reduced-chance-of-cascading-failures\u0022\u003eReduced Chance of Cascading Failures\u003c\/h3\u003e\n\u003cp\u003eBy decoupling the producer and consumer events, the loss of one service does not affect other services, which remain operable.\u003c\/p\u003e\n\u003ch3 id=\u0022reduced-costs\u0022\u003eReduced Costs\u003c\/h3\u003e\n\u003cp\u003eAs each request happens when an event occurs, and with each service decoupled, it prevents wasteful, repeated API calls — reducing the consumption of resources.\u003c\/p\u003e\n\u003ch3 id=\u0022improved-customer-experience\u0022\u003eImproved Customer Experience\u003c\/h3\u003e\n\u003cp\u003eAs each event updates customers, increased engagement and reduced waiting time enhance the overall customer experience.\u003c\/p\u003e\n\u003ch3 id=\u0022easier-to-scale\u0022\u003eEasier to Scale\u003c\/h3\u003e\n\u003cp\u003eIf any of the services exceed operational capacity, it\u0026rsquo;s easier to provide additional resources to meet demand. The decoupled architecture also helps protect your application against failures in a specific service.\u003c\/p\u003e\n\u003ch3 id=\u0022agile-development\u0022\u003eAgile Development\u003c\/h3\u003e\n\u003cp\u003eWith the presence of an event router, developers and engineers don\u0026rsquo;t need to write custom code to filter events. Instead, the event router filters and publishes messages to the consumer. The event router also reduces heavy coordination and reliance between the producers and consumers, which helps increase the pace of development.\u003c\/p\u003e\n\u003cp\u003eVarious methods exist for building an EDA, such as WebSockets, webhooks, and server-side events (SSE).\u003c\/p\u003e\n\u003ch2 id=\u0022rest-versus-eda\u0022\u003eREST Versus EDA\u003c\/h2\u003e\n\u003cp\u003eAdopting an EDA approach to applications helps improve the quality of experience and engagement for customers because users constantly receive information as it occurs.\u003c\/p\u003e\n\u003cp\u003eThe request-response-based interaction model of REST architecture represents a one-to-one model where customers must make requests regularly. This model can be frustrating and time-consuming. Additionally, REST employs a tightly coupled structure, which means that a failure in a single service causes other services to fail. This tight coupling makes scalability harder to achieve in the future.\u003c\/p\u003e\n\u003cp\u003eThe EDA architecture services customers based on events. Events trigger a response, and this response keeps customers in the loop about the service.\u003c\/p\u003e\n\u003cp\u003eEDAs follow the pub-sub messaging model, where the publisher and subscriber services are separate from each other. The pub-sub model decouples the publisher and subscriber channels and communicates through a message broker. This separation of their services allows for asynchronous receiving and delivery of messages by the broker.\u003c\/p\u003e\n\u003cp\u003eHere’s how this model works:\u003c\/p\u003e\n\u003cul\u003e\n\u003cli\u003eThe publisher publishes messages to the message broker.\u003c\/li\u003e\n\u003cli\u003eThe message broker organizes the messages into various categories for delivery to the subscriber.\u003c\/li\u003e\n\u003c\/ul\u003e\n\u003cp\u003eThis decoupled pub-sub messaging system makes event notification seamless. Publishers must only send their messages and rely on message brokers to deliver them when needed, making it ideal for most applications. The decoupled model also allows the continuous addition of streaming data sources and is easily scalable.\u003c\/p\u003e\n\u003cp\u003eFurthermore, most EDAs use a decoupled system and separate the publisher service from the subscriber service. Therefore, the other service proceeds as planned even if another service fails.\u003c\/p\u003e\n\u003ch2 id=\u0022how-eda-helps-support-performance-sensitive-applications-a-sample-case\u0022\u003eHow EDA Helps Support Performance-Sensitive Applications: A Sample Case\u003c\/h2\u003e\n\u003cp\u003eLet\u0026rsquo;s explore how an EDA helps a stock-trading application keep its users informed with stock market updates to make timely, informed decisions. Since most high-performance trading applications rely on real-time information and algorithms to make decisions, they use streaming and RESTful APIs to access critical information.\u003c\/p\u003e\n\u003cp\u003eAll stock trading applications contain the scrolling ticker, which gives information on the price of a stock at a given time, quantity traded, a green ascending arrow for an increased value from the day before, a red descending value for a reduced value from the day before, and the net price change. The changes in the stock ticker occur through asynchronous APIs and help users evaluate the market sentiment at each point in time.\u003c\/p\u003e\n\u003cp\u003eUsers can receive market insights, order information, and risk insights from this trading application by subscribing to market providers. For instance, EDAs provide applications with the ability to perform actions like making decisions on buying an amount of stock when it achieves a specific price range or informing users of certain events.\u003c\/p\u003e\n\u003cp\u003eAdditionally, since dashboards use the incoming stream of data to visualize information, investors can easily access the state of the market and make quick business decisions.\u003c\/p\u003e\n\u003ch2 id=\u0022summary\u0022\u003eSummary\u003c\/h2\u003e\n\u003cp\u003eTo ensure a better customer experience, keeping customers in the loop as events occur is necessary. With the adoption of an EDA, customers receive a notice each time an event occurs and do not have to make a request each time they need information. EDA microservices require producer and consumer services connected by an event router that helps publish information to consumers.  It is easy to scale these services because you have them loosely coupled.\u003c\/p\u003e\n\u003cp\u003eThe REST API architecture, on the other hand, is dependent mainly on customers making several requests to receive a response. In addition to reducing the quality of experience, constant calls to the API quickly depletes resources and become costly. The tightly-coupled nature of the services also creates a scalability bottleneck.\u003c\/p\u003e\n\u003cp\u003eEDAs are essential in most applications today, particularly for performance-sensitive applications like financial applications, where a delay of mere seconds could result in losses worth millions.\u003c\/p\u003e\n"}]</script></head><body class='page bg-secondary'><div id=main-menu-mobile class=main-menu-mobile><ul></ul></div><div class=wrapper><div class='header sticky-top bg-secondary'><div class=container><div class=logo><a href=https://www.pulsar-neighborhood.io><img src=/svg/Pulsar-Neighborhood-Logo.svg class=img-fluid></a></div><div class=logo-mobile><a href=https://www.pulsar-neighborhood.io><img src=/svg/Neighborhood-Icon.svg class=img-fluid></a></div><div id=main-menu class=main-menu><ul><li><a href=/about><span>About The Pulsar Neighborhood</span></a></li><li><a href=https://pulsar.apache.org/ target=_blank><span>About Apache Pulsar</span></a></li><li><a href=https://pulsar.apache.org/docs/en/standalone/ target=_blank><span></span>Project Documentation</span></a></li><li><a href=/index.xml><img src=/svg/square-rss-solid.svg title="Subscribe to The Pulsar Neighborhood feed" class=img-fluid style=height:30px></a></li></ul></div><button id=toggle-main-menu-mobile class="hamburger hamburger--slider" type=button>
<span class=hamburger-box><span class=hamburger-inner></span></span></button></div></div><div class="container pt-2 pb-3"><div class=row><div class="col-0 col-md-2"><div class=sidebar><div class=mb-2><a href=/guides/getting-started><div class="col-12 btn btn-success">Get Started with Pulsar</div></a></div><div class="spotlight mb-2 border border-primary rounded"><div class="row bg-primary no-gutters"><div class="col-12 text-secondary p-1">&nbsp;Find Topics</div></div><div class=p-1><div class="row no-gutters"><div class="col-12 mb-1"><h4>Category</h4><ul><li>&nbsp;<a class=text-decoration-none href=/categories/at-the-edge>At the Edge</a> [3]</li><li>&nbsp;<a class=text-decoration-none href=/categories/cluster-administration>Cluster Administration</a> [3]</li><li>&nbsp;<a class=text-decoration-none href=/categories/getting-started>Getting Started</a> [15]</li><li>&nbsp;<a class=text-decoration-none href=/categories/machine-learning>Machine Learning</a> [2]</li><li>&nbsp;<a class=text-decoration-none href=/categories/moving-to-pulsar>Moving to Pulsar</a> [11]</li><li>&nbsp;<a class=text-decoration-none href=/categories/pulsar-architecture>Pulsar Architecture</a> [10]</li><li>&nbsp;<a class=text-decoration-none href=/categories/pulsar-components>Pulsar Components</a> [9]</li><li>&nbsp;<a class=text-decoration-none href=/categories/use-cases>Use Cases</a> [6]</li></ul></div><div class=col-12><h4>View All</h4><div class="mt-1 pb-1"><a href=/articles>Articles</a>
&nbsp;|&nbsp;<a href=/guides>Guides</a>
&nbsp;|&nbsp;<a href=/videos>Videos</a></div></div></div></div></div></div></div><div class="col-12 col-md-8"><div class=container><header class=mb-3><div class=pb-2><img src=https://user-images.githubusercontent.com/16946028/175393332-fbd80156-a0a1-4f96-84a2-56d01e6bc16e.png alt="REST Versus Event Driven Architecture - Why It's Time to Switch From Request Based Architecture" class=img-fluid style=max-width:85%;max-height:200px></div><h1>REST Versus Event Driven Architecture - Why It's Time to Switch From Request Based Architecture</h1><div class="row no-gutters"><div class="col col-auto mr-1">Categories:</div><div class="col col-auto"><a class=text-decoration-none href=/categories/getting-started>Getting Started</a>,&nbsp;</div><div class="col col-auto"><a class=text-decoration-none href=/categories/moving-to-pulsar>Moving to Pulsar</a>,&nbsp;</div><div class="col col-auto"><a class=text-decoration-none href=/categories/use-cases>Use Cases</a></div></div></header><div class="row mb-3 no-gutters border-top border-bottom"><div class=col-2><ul class="list-group list-group-horizontal mt-1 mb-1"><li class="list-group-item flex-fill border-0 p-0 mr-3"><a href="https://www.linkedin.com/sharing/share-offsite/?mini=true&url=https%3a%2f%2fwww.pulsar-neighborhood.io%2farticles%2frest-versus-event-driven-architecture-why-it-s-time-to-switch-from-request-based-architecture%2f&title=REST%20Versus%20Event%20Driven%20Architecture%20-%20Why%20It%27s%20Time%20to%20Switch%20From%20Request%20Based%20Architecture" target=_blank><img src=/svg/linkedin-in-brands.svg title="Share this on LinkedIn" class=img-fluid></a></li><li class="list-group-item flex-fill border-0 p-0 mr-3"><a target=_blank href="https://twitter.com/intent/tweet?text=REST%20Versus%20Event%20Driven%20Architecture%20-%20Why%20It%27s%20Time%20to%20Switch%20From%20Request%20Based%20Architecture&url=https%3a%2f%2fwww.pulsar-neighborhood.io%2farticles%2frest-versus-event-driven-architecture-why-it-s-time-to-switch-from-request-based-architecture%2f&hashtags=apachepulsar&via=pulsar_neighbor"><img src=/svg/twitter-brands.svg title="Share this on Twitter" class=img-fluid></a></li></ul></div><div class="col text-right"><span class=text-muted>Author:</span> Pulsar Neighborhood<br><span class=text-muted>Published:</span> June 23, 2022</div></div><article><p>Building for an improved customer experience should be at the forefront of every organization’s mind during development. Improving engagement and customer information is one way of ensuring an enhanced customer experience.</p><p>For example, social media websites like Instagram and Facebook notify you when someone likes, comments, or follows you. Likewise, your favorite food vendor app tells you when your order is ready and on its way.</p><p>All these immediate notifications are a result of the application of event-driven architecture. Unlike representational state transfer (REST) applications that rely on a back-and-forth exchange (request and response) approach to information, event-driven architectures (EDA) respond based on specific events.</p><p>This article introduces REST and event-driven architectures and explains why organizations should move to an EDA to maximize customer satisfaction.</p><h2 id=a-look-at-rest>A Look at REST</h2><p>REST architecture follows a request and response model, where users must send requests before receiving a response. A REST service application tightly couples each microservice for execution in a pre-arranged sequence.</p><p>REST architectures help define rules for different computer systems to communicate on the internet and create stateless and reliable APIs. The following are two fundamental guiding principles of a REST architecture:</p><ul><li>Client and server separation</li><li>Statelessness</li></ul><h3 id=client-and-server-separation>Client and Server Separation</h3><p>In REST, the separation of concerns principle implements the needs of the client and server separately. Separating the user interface needs from the server needs makes each component easy to scale and evolve independently.</p><h3 id=statelessness>Statelessness</h3><p>In REST architecture, the server retains no information from a session, and the receiver understands the information in each session without needing context from previous sessions. This quality helps improve performance in high-volume operations by reducing server load.</p><p>Other guiding principles of REST include its ability to cache information and its layered system, which helps promote system scalability.</p><p><img src=https://user-images.githubusercontent.com/16946028/175393212-e5d354a9-f2c4-4922-be7f-9e6a1c16f044.png alt="REST architecture"></p><p>As a request-based architecture, a single orchestrator coordinates all interactions between microservices, introducing a single failure point.</p><p>Here are some limitations of REST:</p><ul><li>Poor customer experience</li><li>Tightly coupled architecture introduces cascading failures</li><li>Hard to scale</li><li>Waste of resources</li></ul><h3 id=poor-customer-experience>Poor Customer Experience</h3><p>Since customers must send in a request for information each time, it increases the wait time for a single round trip and can be frustrating. For example, the cumulative time spent on the food vendor application is the sum of all the time spent on each microservice (inventory, stock, billing, delivery).</p><h3 id=tightly-coupled-architecture-introduces-cascading-failures>Tightly Coupled Architecture Introduces Cascading Failures</h3><p>As each microservice in a REST application is mainly dependent and connected, a failure in one service causes an overall system failure. Failures from the inventory service mean updates to the next microservice (billing) in the sequence never happens, which leads to cascading failure.</p><h3 id=hard-to-scale>Hard to Scale</h3><p>Due to the large amounts of interconnected APIs, the application becomes harder to scale with multiple endpoints present.</p><h3 id=waste-of-resources>Waste of Resources</h3><p>As each request follows a predefined sequence of events before fetching a response, a single action makes several unnecessary API calls to a server. This wastes resources for both the client and the server, ultimately increasing costs.</p><h2 id=a-look-at-eda>A Look at EDA</h2><p>Unlike REST, EDA uses an event to trigger and communicate between loosely coupled microservices. An event could be a change in a state or an update, like adding an extra item to a shopping cart or canceling a ride.</p><p>EDA contains three key components. It includes an event producer, an event router, and an event consumer. When an event occurs, the producers publish it to the event router, filtering it and relating the information to the consumers. You can scale, update, and deploy producer and consumer services independently because they exist independently.</p><p>Other names for EDAs include push, streaming, or asynchronous APIs. It performs two essential functions:</p><ul><li>It acts as a medium by which consumers subscribe to events of interest.</li><li>It ensures synchronous delivery of events to subscribed consumers.</li></ul><p>Some advantages of EDA are:</p><ul><li>Reduced chance of cascading failures</li><li>Reduced costs</li><li>Improved customer experience</li><li>Easier to scale</li><li>Agile development</li></ul><p>Let’s take a closer look at each of these.</p><h3 id=reduced-chance-of-cascading-failures>Reduced Chance of Cascading Failures</h3><p>By decoupling the producer and consumer events, the loss of one service does not affect other services, which remain operable.</p><h3 id=reduced-costs>Reduced Costs</h3><p>As each request happens when an event occurs, and with each service decoupled, it prevents wasteful, repeated API calls — reducing the consumption of resources.</p><h3 id=improved-customer-experience>Improved Customer Experience</h3><p>As each event updates customers, increased engagement and reduced waiting time enhance the overall customer experience.</p><h3 id=easier-to-scale>Easier to Scale</h3><p>If any of the services exceed operational capacity, it&rsquo;s easier to provide additional resources to meet demand. The decoupled architecture also helps protect your application against failures in a specific service.</p><h3 id=agile-development>Agile Development</h3><p>With the presence of an event router, developers and engineers don&rsquo;t need to write custom code to filter events. Instead, the event router filters and publishes messages to the consumer. The event router also reduces heavy coordination and reliance between the producers and consumers, which helps increase the pace of development.</p><p>Various methods exist for building an EDA, such as WebSockets, webhooks, and server-side events (SSE).</p><h2 id=rest-versus-eda>REST Versus EDA</h2><p>Adopting an EDA approach to applications helps improve the quality of experience and engagement for customers because users constantly receive information as it occurs.</p><p>The request-response-based interaction model of REST architecture represents a one-to-one model where customers must make requests regularly. This model can be frustrating and time-consuming. Additionally, REST employs a tightly coupled structure, which means that a failure in a single service causes other services to fail. This tight coupling makes scalability harder to achieve in the future.</p><p>The EDA architecture services customers based on events. Events trigger a response, and this response keeps customers in the loop about the service.</p><p>EDAs follow the pub-sub messaging model, where the publisher and subscriber services are separate from each other. The pub-sub model decouples the publisher and subscriber channels and communicates through a message broker. This separation of their services allows for asynchronous receiving and delivery of messages by the broker.</p><p>Here’s how this model works:</p><ul><li>The publisher publishes messages to the message broker.</li><li>The message broker organizes the messages into various categories for delivery to the subscriber.</li></ul><p>This decoupled pub-sub messaging system makes event notification seamless. Publishers must only send their messages and rely on message brokers to deliver them when needed, making it ideal for most applications. The decoupled model also allows the continuous addition of streaming data sources and is easily scalable.</p><p>Furthermore, most EDAs use a decoupled system and separate the publisher service from the subscriber service. Therefore, the other service proceeds as planned even if another service fails.</p><h2 id=how-eda-helps-support-performance-sensitive-applications-a-sample-case>How EDA Helps Support Performance-Sensitive Applications: A Sample Case</h2><p>Let&rsquo;s explore how an EDA helps a stock-trading application keep its users informed with stock market updates to make timely, informed decisions. Since most high-performance trading applications rely on real-time information and algorithms to make decisions, they use streaming and RESTful APIs to access critical information.</p><p>All stock trading applications contain the scrolling ticker, which gives information on the price of a stock at a given time, quantity traded, a green ascending arrow for an increased value from the day before, a red descending value for a reduced value from the day before, and the net price change. The changes in the stock ticker occur through asynchronous APIs and help users evaluate the market sentiment at each point in time.</p><p>Users can receive market insights, order information, and risk insights from this trading application by subscribing to market providers. For instance, EDAs provide applications with the ability to perform actions like making decisions on buying an amount of stock when it achieves a specific price range or informing users of certain events.</p><p>Additionally, since dashboards use the incoming stream of data to visualize information, investors can easily access the state of the market and make quick business decisions.</p><h2 id=summary>Summary</h2><p>To ensure a better customer experience, keeping customers in the loop as events occur is necessary. With the adoption of an EDA, customers receive a notice each time an event occurs and do not have to make a request each time they need information. EDA microservices require producer and consumer services connected by an event router that helps publish information to consumers. It is easy to scale these services because you have them loosely coupled.</p><p>The REST API architecture, on the other hand, is dependent mainly on customers making several requests to receive a response. In addition to reducing the quality of experience, constant calls to the API quickly depletes resources and become costly. The tightly-coupled nature of the services also creates a scalability bottleneck.</p><p>EDAs are essential in most applications today, particularly for performance-sensitive applications like financial applications, where a delay of mere seconds could result in losses worth millions.</p></article><div class="row border border-primary rounded"><div class="col p-2"><h3>You might also like...</h3><div class=row><div class="col text-center p-2"><div><a href=/articles/do-i-have-time-to-learn-event-streaming/><img src=https://user-images.githubusercontent.com/16946028/168359869-21a4d6b6-b761-43c9-8b1d-2a5d3ee2f83c.png alt class=img-fluid style=max-width:150px></a></div><div class=pt-2><a href=/articles/do-i-have-time-to-learn-event-streaming/>Do I Have Time to Learn Event Streaming?</a></div><div class=pt-2>In this article, we’ll explore what event streaming is, how it works, and discuss the growing …</div></div><div class="col text-center p-2"><div><a href=/articles/apache-pulsar-versus-apache-kafka/><img src=https://user-images.githubusercontent.com/16946028/163627966-dc0b4e18-d7ac-4d75-889f-2844926d11be.png alt class=img-fluid style=max-width:150px></a></div><div class=pt-2><a href=/articles/apache-pulsar-versus-apache-kafka/>Apache Pulsar Versus Apache Kafka</a></div><div class=pt-2>In this article, we'll evaluate the features, architectures, performance, and use cases of Apache …</div></div><div class="col text-center p-2"><div><a href=/articles/why-managed-apache-pulsar-is-the-right-choice/><img src=https://user-images.githubusercontent.com/16946028/175392736-555608d6-d5cb-426a-b41a-7b2babadff9c.png alt class=img-fluid style=max-width:150px></a></div><div class=pt-2><a href=/articles/why-managed-apache-pulsar-is-the-right-choice/>Why Managed Apache Pulsar Is the Right Choice</a></div><div class=pt-2>In this article, we’ll explore why and how using a managed Apache Pulsar service saves you time and …</div></div></div></div></div><br><div id=disqus_thread></div><script type=text/javascript>(function(){if(window.location.hostname=="localhost")return;var t,e=document.createElement("script");e.type="text/javascript",e.async=!0,t="pulsar-neighborhood",e.src="//"+t+".disqus.com/embed.js",(document.getElementsByTagName("head")[0]||document.getElementsByTagName("body")[0]).appendChild(e)})()</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript></div></div><div class="col-0 col-md-2"><nav class="navbar navbar-light mb-3"><div class=row><div class=col-12><h4>In this article</h4></div><div class="col-12 border-left border-primary pr-0"><nav id=TableOfContents><ul><li><a href=#a-look-at-rest>A Look at REST</a><ul><li><a href=#client-and-server-separation>Client and Server Separation</a></li><li><a href=#statelessness>Statelessness</a></li><li><a href=#poor-customer-experience>Poor Customer Experience</a></li><li><a href=#tightly-coupled-architecture-introduces-cascading-failures>Tightly Coupled Architecture Introduces Cascading Failures</a></li><li><a href=#hard-to-scale>Hard to Scale</a></li><li><a href=#waste-of-resources>Waste of Resources</a></li></ul></li><li><a href=#a-look-at-eda>A Look at EDA</a><ul><li><a href=#reduced-chance-of-cascading-failures>Reduced Chance of Cascading Failures</a></li><li><a href=#reduced-costs>Reduced Costs</a></li><li><a href=#improved-customer-experience>Improved Customer Experience</a></li><li><a href=#easier-to-scale>Easier to Scale</a></li><li><a href=#agile-development>Agile Development</a></li></ul></li><li><a href=#rest-versus-eda>REST Versus EDA</a></li><li><a href=#how-eda-helps-support-performance-sensitive-applications-a-sample-case>How EDA Helps Support Performance-Sensitive Applications: A Sample Case</a></li><li><a href=#summary>Summary</a></li></ul></nav></div></div></nav></div></div></div></div><div class="sub-footer m-5"><div class=row><div class="col-12 text-center"><a href=https://github.com/pulsar-neighborhood/pulsar-neighborhood.github.io/blob/main/content/articles/REST-Versus-Event-Driven-Architecture-Why-It-s-Time-To-Switch-From-Request-Based-Architecture.md target=_blank>Improve this page</a></div></div><div class="col-8 offset-2"><hr class="bg-primary text-primary"></div><div class="sub-footer-inner mt-2"><div><div class=mb-1>Pulsar Neighborhood</div><div><ul><li style=width:40px><a href=https://github.com/pulsar-neighborhood target=_blank><img src=/svg/github-brands.svg title="Pulsar Neighborhood on GitHub" class=img-fluid></a></li><li class="ml-3 mr-1" style=width:40px><a href=https://twitter.com/pulsar_neighbor target=_blank><img src=/svg/twitter-brands.svg title="Pulsar Neighborhood on Twitter" class=img-fluid></a></li><li style=width:40px><a href=https://www.youtube.com/c/ApachePulsarNeighborhood target=_blank><img src=/svg/youtube-brands.svg title="Pulsar Neighborhood on YouTube" class=img-fluid></a></li><li style=width:40px><a href=https://datastudio.google.com/reporting/743d9f31-c80f-4e60-b520-730631d3c250 target=_blank><img src=/png/google-analytics.png title="Pulsar Neighborhood analytics" class=img-fluid></a></li></ul></div></div><div class=p-5></div><div><div class=mb-1>Apache Pulsar</div><div><ul><li style=width:40px><a href=https://pulsar.apache.org target=_blank><img src=/png/pulsar-icon.jpg title="Apache Pulsar project home" class=img-fluid></a></li><li class="ml-3 mr-1" style=width:40px><a href=https://github.com/apache-pulsar target=_blank><img src=/svg/github-brands.svg title="Apache Pulsar on GitHub" class=img-fluid></a></li><li class=mr-1 style=width:40px><a href=https://twitter.com/Apache_Pulsar target=_blank><img src=/svg/twitter-brands.svg title="Apache Pulsar on Twitter" class=img-fluid></a></li><li class=mr-1 style=width:30px><a href=https://stackoverflow.com/questions/tagged/apache-pulsar target=_blank><img src=/svg/stack-overflow-brands.svg title="Apache Pulsar on Stackoverflow" class=img-fluid></a></li><li style=width:40px><a href=https://apache-pulsar.slack.com target=_blank><img src=/svg/slack-brands.svg title="Apache Pulsar slack channel" class=img-fluid></a></li></ul></div></div></div><div class="row text-center mb-3"><div class=col-12><a class="btn btn-info" href=https://pulsar.apache.org/community/ target=_blank>Join the Pulsar community</a></div></div><div class="row text-center"><div class="col-12 text-center"><div><a href=https://github.com/pulsar-neighborhood/pulsar-neighborhood.github.io/issues/new/choose>Contact Us</a></div></div></div></div><script type=text/javascript src=/js/scripts.min.8efe3e711319c2d0a300a084134e3f3bedcb60dce21f1e0ef12767f654242b44.js></script><script src=https://ajax.googleapis.com/ajax/libs/jquery/3.6.0/jquery.min.js></script><script src=https://cdn.jsdelivr.net/npm/bootstrap@4.6.1/dist/js/bootstrap.bundle.min.js integrity=sha384-fQybjgWLrvvRgtW6bFlB7jaZrFsaBXjsOMm/tB9LTS58ONXgqbR9W8oWht/amnpF crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-8S9SD43SBH"></script><script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-8S9SD43SBH")</script></body></html>
<!doctype html><html lang=en><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="ie=edge"><title>Understanding the Differences Between Message Queues and Streaming - Pulsar Neighborhood</title><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="Message queues & streaming are both valid solutions for event-based architectures depending on the nature of the application workload & the foreseeable outcome."><meta property="og:title" content="Understanding the Differences Between Message Queues and Streaming - Pulsar Neighborhood"><meta property="og:type" content="article"><meta property="og:url" content="https://www.pulsar-neighborhood.io/articles/understanding-the-differences-between-message-queues-and-streaming/"><meta property="og:image" content="https://user-images.githubusercontent.com/16946028/159678986-ccaf6b62-e9ea-43c5-8901-3361f5392bfb.png"><meta name=description content="Message queues & streaming are both valid solutions for event-based architectures depending on the nature of the application workload & the foreseeable outcome."><meta name=twitter:site content="@pulsar_neighbor"><meta name=twitter:creator content="@pulsar_neighbor"><link rel=alternate type=application/rss+xml href=/index.xml title="Site Title"><meta name=google-site-verification content="m-1Z-0k0EvG9PD7R24pKuETSaBpEvqoXgOYT-0MtuPU"><link rel=icon href=https://www.pulsar-neighborhood.io/favicon.png><link rel=canonical href=https://www.pulsar-neighborhood.io/articles/understanding-the-differences-between-message-queues-and-streaming/><link rel=stylesheet href=/css/style.32ad96ee983b063b549f59db931afb8f0db25424bf2d687e1122748a7d183f73.css><style>.ctct-form-defaults{padding:15px!important}</style><script type=application/ld+json>[{"@context":"http://schema.org","@type":"WebPage","name":"Pulsar Neighborhood - Understanding the Differences Between Message Queues and Streaming","description":"Message queues \u0026 streaming are both valid solutions for event-based architectures depending on the nature of the application workload \u0026 the foreseeable outcome.","publisher":{"@type":"Organization","name":"Pulsar Neighborhood"}},{"@context":"http://schema.org","@type":"BlogPosting","image":"https://user-images.githubusercontent.com/16946028/159678986-ccaf6b62-e9ea-43c5-8901-3361f5392bfb.png","url":"https:\/\/www.pulsar-neighborhood.io\/articles\/understanding-the-differences-between-message-queues-and-streaming\/","publisher":"Pulsar Neighborhood","headline":"Understanding the Differences Between Message Queues and Streaming","dateCreated":"2022-03-25 14:46:55 -0400 -0400","datePublished":"2022-03-25 14:46:55 -0400 -0400","dateModified":"2022-03-25 14:46:55 -0400 -0400","inLanguage":"en-US","isFamilyFriendly":"true","copyrightYear":"2022","copyrightHolder":"","author":{"@type":"Person","name":"Pulsar Neighborhood","url":"https://www.pulsar-neighborhood.io"},"mainEntityOfPage":"True","articleSection":["getting-started, pulsar-architecture"],"articleBody":"\u003cp\u003eAlmost any application that requires real-time or near-real-time data processing benefits from having a message queue or streaming data processing component in its architecture. Online food ordering apps, e-commerce sites, media streaming services, and online gaming are straightforward examples. But weather apps, smart cars, health status apps with smartwatch technology, or anything Internet of things (IoT) typically rely on a message queue or streaming engine as well.\u003c\/p\u003e\n\u003cp\u003eWhile message queues and streaming apply to similar use cases and use similar technologies, on a technical level they’re entirely different. We’ll compare them here and examine the pros and cons of each solution, touching on message brokers, publisher-subscriber (pub\/sub) architecture, and event-driven scenarios.\u003c\/p\u003e\n\u003cp\u003eWe’ll touch on some use cases to highlight why sometimes one approach is better than the other. Finally, we’ll discuss how the open-source Apache Pulsar platform supports both message queues and streams, with a few subtle differences.\u003c\/p\u003e\n\u003ch2 id=\u0022differences-between-message-queues-and-streaming\u0022\u003eDifferences Between Message Queues and Streaming\u003c\/h2\u003e\n\u003cp\u003eLet’s start by exploring the major differences between message queues and event streaming.\u003c\/p\u003e\n\u003ch3 id=\u0022message-queues\u0022\u003eMessage Queues\u003c\/h3\u003e\n\u003cp\u003eMessage queues transport messages between application components, across applications, or across services in traditional monolith applications, containers, or microservices. Any online transaction processing (OLTP) is a good candidate for message queues.\u003c\/p\u003e\n\u003cp\u003eThink of a message queue as a sequential list of data blocks waiting to be processed.\u003c\/p\u003e\n\u003cp\u003eWhile queues are a fantastic way to send data across different application or service components, they also have some challenges. For example, they have latency, so processing a message takes time.\u003c\/p\u003e\n\u003cp\u003eReliability may also be an issue if the message queue’s unavailability affects the application’s stability. Its reliability also depends on how the application handles failed messages. Intelligence may also be an issue, depending on how developers recognize if the broker has already picked up or processed a message.\u003c\/p\u003e\n\u003cp\u003eFor example, application source A sends a message to a message broker. In turn, application target B picks up and processes the message from the message broker.\u003c\/p\u003e\n\u003cp\u003e\u003cimg src=\u0022https:\/\/user-images.githubusercontent.com\/16946028\/159680203-bdc57a88-0102-4d85-8c3b-5163e4fff4c5.PNG\u0022 alt=\u0022Message queues\u0022\u003e\u003c\/p\u003e\n\u003ch3 id=\u0022streaming\u0022\u003eStreaming\u003c\/h3\u003e\n\u003cp\u003eStream processing typically involves a more significant stream of data events that have already occurred. The events go to a message bus, where the streaming service picks them up.\u003c\/p\u003e\n\u003cp\u003e\u003cimg src=\u0022https:\/\/user-images.githubusercontent.com\/16946028\/159680298-2937e511-30fe-4a70-aea0-0466739103dc.PNG\u0022 alt=\u0022Streaming\u0022\u003e\u003c\/p\u003e\n\u003cp\u003eAny workload generating a large flow of data (a_ _stream) that needs to be processed in real-time is well-suited for stream processing. A stream is an infinite sequence of messages that are generated and sent continuously.\u003c\/p\u003e\n\u003cp\u003eStream processing architectures do have their challenges. The first is performance, as the application must handle the load of incoming data streams. Other challenges include order and logic, as we have to determine how our application should process the input stream.\u003c\/p\u003e\n\u003cp\u003eFinally, stream processing is real-time. While this may be what we want in most cases, we might also have a batch-processing requirement.\u003c\/p\u003e\n\u003ch3 id=\u0022message-brokers\u0022\u003eMessage Brokers\u003c\/h3\u003e\n\u003cp\u003eMapping both technologies with each other immediately introduces another component: the message broker or message bus. A message broker is an interface between the message’s originator — a producer or publisher — and the destination handling system — a receiver or consumer, sometimes called a subscriber. It handles the message queue.\u003c\/p\u003e\n\u003cp\u003eHowever, message brokers can combine several queues, providing scalability and high availability. Apache Kafka is one example of a message broker system.\u003c\/p\u003e\n\u003cp\u003eBrokers are sometimes considered the more intelligent part of the solution stack. They’re typically responsible for message persistence and replication. So, if a message queue fails, the broker recognizes this and sends the incoming flow of messages to another queue. Since the message broker manages the communication between the producer and the consumer, neither component experiences downtime nor interruptions in message handling.\u003c\/p\u003e\n\u003cp\u003eTo address one of the message queue challenges, the broker can also recognize the message arrival order and how to process them.\u003c\/p\u003e\n\u003ch3 id=\u0022message-queue-versus-streaming-architecture\u0022\u003eMessage Queue Versus Streaming Architecture\u003c\/h3\u003e\n\u003cp\u003ePerformance is critical in a modern microservices architecture. So, we need to make sure we’re choosing an architecture that benefits us the most.\u003c\/p\u003e\n\u003cp\u003eA message queue is asynchronous since messages move into a queue, waiting to be picked up. The receiving component may need to poll the message queue to find out if there are any new messages.\u003c\/p\u003e\n\u003cp\u003eIn contrast, an application should process a continuous stream of messages as they’re generated, using an active, ongoing process. Event-driven processing or event-based architecture often accomplishes this.\u003c\/p\u003e\n\u003cp\u003eThe magic keyword in event-based architecture is “trigger.” Whenever some event occurs, another process kicks off.\u003c\/p\u003e\n\u003cp\u003eThis trigger could move something to a queue, a stand-alone activity, like saving the camera image to storage or validating credit card details with the credit card company. However, the event-based architecture can also work in a more significant stream, like checking for a robbery via hundreds of surveillance cameras writing to storage or validating thousands of payment transactions to detect fraud. In these cases, the architecture moves data to a stream and performs real-time analytics.\u003c\/p\u003e\n\u003cp\u003eMessage queues and streaming are both valid solutions for event-based architectures. Deciding which is best depends on the nature of the application workload and solution and the foreseeable outcome. For example, it would be acceptable to use a message queue for a stand-alone credit card validation. However, it wouldn’t be a viable architecture for payment transaction fraud detection.\u003c\/p\u003e\n\u003cp\u003eLet’s compare the benefits of message queues and stream processing.\u003c\/p\u003e\n\u003ctable\u003e\n\u003cthead\u003e\n\u003ctr\u003e\n\u003cth style=\u0022text-align:left\u0022\u003eMessage queue\u003c\/th\u003e\n\u003cth style=\u0022text-align:left\u0022\u003eStream\u003c\/th\u003e\n\u003c\/tr\u003e\n\u003c\/thead\u003e\n\u003ctbody\u003e\n\u003ctr\u003e\n\u003ctd style=\u0022text-align:left\u0022\u003eControls data volumes\u003c\/td\u003e\n\u003ctd style=\u0022text-align:left\u0022\u003eHandles real-time data generation\u003c\/td\u003e\n\u003c\/tr\u003e\n\u003ctr\u003e\n\u003ctd style=\u0022text-align:left\u0022\u003eEnables batch processing\u003c\/td\u003e\n\u003ctd style=\u0022text-align:left\u0022\u003eAllows real-time analytics\u003c\/td\u003e\n\u003c\/tr\u003e\n\u003ctr\u003e\n\u003ctd style=\u0022text-align:left\u0022\u003eRouting logic based on message brokers\u003c\/td\u003e\n\u003ctd style=\u0022text-align:left\u0022\u003eMultiple subscribers to control message flow traffic\u003c\/td\u003e\n\u003c\/tr\u003e\n\u003ctr\u003e\n\u003ctd style=\u0022text-align:left\u0022\u003eAsynchronous data processing\u003c\/td\u003e\n\u003ctd style=\u0022text-align:left\u0022\u003eSynchronous, continuous data flow\u003c\/td\u003e\n\u003c\/tr\u003e\n\u003c\/tbody\u003e\n\u003c\/table\u003e\n\u003ch2 id=\u0022message-queue-and-streaming-solutions\u0022\u003eMessage Queue and Streaming Solutions\u003c\/h2\u003e\n\u003cp\u003eThere are many message queue and streaming solutions available. Let’s take a closer look at Apache Pulsar as an example.\u003c\/p\u003e\n\u003cp\u003eYahoo originally developed Apache Pulsar to enable various data flows within their cloud environment. Now, it’s open-sourced through the Apache Software Foundation.\u003c\/p\u003e\n\u003cp\u003eDevelopers find it to be a robust and scalable messaging and streaming platform. We can deploy Pulsar on bare metal as physical or virtual machines, run it inside Docker containers, or scale it within Kubernetes clusters, depending on the organization or workload application’s needs.\u003c\/p\u003e\n\u003cp\u003ePulsar’s core is the publisher-subscriber (pub\/sub) architecture. Producers create messages and publish them to topics. Consumers subscribe to topics to recognize the specific messages they must handle.\u003c\/p\u003e\n\u003cp\u003e\u003cimg src=\u0022https:\/\/user-images.githubusercontent.com\/16946028\/159680446-ad072a9f-3f0e-4da8-9b4d-aaeac472f891.PNG\u0022 alt=\u0022Message queue and streaming solutions\u0022\u003e\u003c\/p\u003e\n\u003cp\u003eEach Pulsar instance contains one or more Pulsar clusters. The Pulsar clusters are message brokers, delivering messages from the producers to the consumers. Pulsar can replicate data across clusters to optimize performance and scale.\u003c\/p\u003e\n\u003cp\u003eApart from the message brokers, Pulsar also relies on Apache BookKeeper as a temporary message store and Apache ZooKeeper to orchestrate and coordinate across Pulsar clusters. \u003ca href=\u0022https:\/\/pulsar.apache.org\/docs\/en\/concepts-architecture-overview\/\u0022 target=\u0022_blank\u0022\u003ePulsar’s architecture\u003c\/a\u003e provides everything we need to handle traditional message queues or resource-intensive continuous streams.\u003c\/p\u003e\n\u003cp\u003eLet’s say our application needs direct communication between the producer and consumer. A message queue can manage the messages that the application can’t process immediately. Once the consumer acknowledges the message, it is removed from the queue. Payment transactions, food ordering apps, and e-commerce benefit from a Pulsar message queue architecture.\u003c\/p\u003e\n\u003cp\u003eOr, perhaps our application workload involves producers generating a vast amount of data that we need to analyze in real-time, like IoT or payment fraud detection. Pulsar can integrate this streaming analytics processing as well. Pulsar’s stream processing unit, Pulsar Functions, takes ownership of the analysis and handles the messages routing across the producer and consumer.\u003c\/p\u003e\n\u003cp\u003eIn the past, developers needed to use different solutions for messaging and streams. Pulsar’s most significant benefit is combining traditional message queueing with stream processing within the same architecture. This ability simplifies the architecture, reducing the burden of maintaining skills across different platforms and solutions.\u003c\/p\u003e\n\u003ch2 id=\u0022conclusion\u0022\u003eConclusion\u003c\/h2\u003e\n\u003cp\u003eE-commerce order processing benefits from message queueing, while streaming offers real-time data analytics on a continuous influx of data, such as IoT or global payment transactions. Each solution has its challenges and benefits.\u003c\/p\u003e\n\u003cp\u003eYour decision on which to use depends on your specific needs. If your application workload needs queuing and streaming, you may consider a highly-available, scalable, robust all-in-one solution like Pulsar.\u003c\/p\u003e\n\u003cp\u003eNow that you understand the differences between these seemingly-similar solutions, you’re better equipped to decide which is best for your application.\u003c\/p\u003e\n"}]</script></head><body class='page bg-secondary'><div id=main-menu-mobile class=main-menu-mobile><ul></ul></div><div class=wrapper><div class='header sticky-top bg-secondary'><div class=container><div class=logo><a href=https://www.pulsar-neighborhood.io><img src=/svg/Pulsar-Neighborhood-Logo.svg class=img-fluid></a></div><div class=logo-mobile><a href=https://www.pulsar-neighborhood.io><img src=/svg/Neighborhood-Icon.svg class=img-fluid></a></div><div id=main-menu class=main-menu><ul><li><a href=/about><span>About The Pulsar Neighborhood</span></a></li><li><a href=https://pulsar.apache.org/ target=_blank><span>About Apache Pulsar</span></a></li><li><a href=https://pulsar.apache.org/docs/en/standalone/ target=_blank><span></span>Project Documentation</span></a></li><li><a href=/index.xml><img src=/svg/square-rss-solid.svg title="Subscribe to The Pulsar Neighborhood feed" class=img-fluid style=height:30px></a></li></ul></div><button id=toggle-main-menu-mobile class="hamburger hamburger--slider" type=button>
<span class=hamburger-box><span class=hamburger-inner></span></span></button></div></div><div class="container pt-2 pb-3"><div class=row><div class="col-0 col-md-2"><div class=sidebar><div class=mb-2><a href=/guides/getting-started><div class="col-12 btn btn-success">Get Started with Pulsar</div></a></div><div class="spotlight mb-2 border border-primary rounded"><div class="row bg-primary no-gutters"><div class="col-12 text-secondary p-1">&nbsp;Find Topics</div></div><div class=p-1><div class="row no-gutters"><div class="col-12 mb-1"><h4>Category</h4><ul><li>&nbsp;<a class=text-decoration-none href=/categories/at-the-edge>At the Edge</a> [3]</li><li>&nbsp;<a class=text-decoration-none href=/categories/cluster-administration>Cluster Administration</a> [3]</li><li>&nbsp;<a class=text-decoration-none href=/categories/getting-started>Getting Started</a> [15]</li><li>&nbsp;<a class=text-decoration-none href=/categories/machine-learning>Machine Learning</a> [2]</li><li>&nbsp;<a class=text-decoration-none href=/categories/moving-to-pulsar>Moving to Pulsar</a> [10]</li><li>&nbsp;<a class=text-decoration-none href=/categories/pulsar-architecture>Pulsar Architecture</a> [10]</li><li>&nbsp;<a class=text-decoration-none href=/categories/pulsar-components>Pulsar Components</a> [8]</li><li>&nbsp;<a class=text-decoration-none href=/categories/use-cases>Use Cases</a> [4]</li></ul></div><div class=col-12><h4>View All</h4><div class="mt-1 pb-1"><a href=/articles>Articles</a>
&nbsp;|&nbsp;<a href=/guides>Guides</a>
&nbsp;|&nbsp;<a href=/videos>Videos</a></div></div></div></div></div></div></div><div class="col-12 col-md-8"><div class=container><header class=mb-3><div class=pb-2><img src=https://user-images.githubusercontent.com/16946028/159678986-ccaf6b62-e9ea-43c5-8901-3361f5392bfb.png alt="Understanding the Differences Between Message Queues and Streaming" class=img-fluid style=max-width:85%;max-height:200px></div><h1>Understanding the Differences Between Message Queues and Streaming</h1><div class="row no-gutters"><div class="col col-auto mr-1">Categories:</div><div class="col col-auto"><a class=text-decoration-none href=/categories/getting-started>Getting Started</a>,&nbsp;</div><div class="col col-auto"><a class=text-decoration-none href=/categories/pulsar-architecture>Pulsar Architecture</a></div></div></header><div class="row mb-3 no-gutters border-top border-bottom"><div class=col-2><ul class="list-group list-group-horizontal mt-1 mb-1"><li class="list-group-item flex-fill border-0 p-0 mr-3"><a href="https://www.linkedin.com/sharing/share-offsite/?mini=true&url=https%3a%2f%2fwww.pulsar-neighborhood.io%2farticles%2funderstanding-the-differences-between-message-queues-and-streaming%2f&title=Understanding%20the%20Differences%20Between%20Message%20Queues%20and%20Streaming" target=_blank><img src=/svg/linkedin-in-brands.svg title="Share this on LinkedIn" class=img-fluid></a></li><li class="list-group-item flex-fill border-0 p-0 mr-3"><a target=_blank href="https://twitter.com/intent/tweet?text=Understanding%20the%20Differences%20Between%20Message%20Queues%20and%20Streaming&url=https%3a%2f%2fwww.pulsar-neighborhood.io%2farticles%2funderstanding-the-differences-between-message-queues-and-streaming%2f&hashtags=apachepulsar&via=pulsar_neighbor"><img src=/svg/twitter-brands.svg title="Share this on Twitter" class=img-fluid></a></li></ul></div><div class="col text-right"><span class=text-muted>Author:</span> Pulsar Neighborhood<br><span class=text-muted>Published:</span> March 25, 2022</div></div><article><p>Almost any application that requires real-time or near-real-time data processing benefits from having a message queue or streaming data processing component in its architecture. Online food ordering apps, e-commerce sites, media streaming services, and online gaming are straightforward examples. But weather apps, smart cars, health status apps with smartwatch technology, or anything Internet of things (IoT) typically rely on a message queue or streaming engine as well.</p><p>While message queues and streaming apply to similar use cases and use similar technologies, on a technical level they’re entirely different. We’ll compare them here and examine the pros and cons of each solution, touching on message brokers, publisher-subscriber (pub/sub) architecture, and event-driven scenarios.</p><p>We’ll touch on some use cases to highlight why sometimes one approach is better than the other. Finally, we’ll discuss how the open-source Apache Pulsar platform supports both message queues and streams, with a few subtle differences.</p><h2 id=differences-between-message-queues-and-streaming>Differences Between Message Queues and Streaming</h2><p>Let’s start by exploring the major differences between message queues and event streaming.</p><h3 id=message-queues>Message Queues</h3><p>Message queues transport messages between application components, across applications, or across services in traditional monolith applications, containers, or microservices. Any online transaction processing (OLTP) is a good candidate for message queues.</p><p>Think of a message queue as a sequential list of data blocks waiting to be processed.</p><p>While queues are a fantastic way to send data across different application or service components, they also have some challenges. For example, they have latency, so processing a message takes time.</p><p>Reliability may also be an issue if the message queue’s unavailability affects the application’s stability. Its reliability also depends on how the application handles failed messages. Intelligence may also be an issue, depending on how developers recognize if the broker has already picked up or processed a message.</p><p>For example, application source A sends a message to a message broker. In turn, application target B picks up and processes the message from the message broker.</p><p><img src=https://user-images.githubusercontent.com/16946028/159680203-bdc57a88-0102-4d85-8c3b-5163e4fff4c5.PNG alt="Message queues"></p><h3 id=streaming>Streaming</h3><p>Stream processing typically involves a more significant stream of data events that have already occurred. The events go to a message bus, where the streaming service picks them up.</p><p><img src=https://user-images.githubusercontent.com/16946028/159680298-2937e511-30fe-4a70-aea0-0466739103dc.PNG alt=Streaming></p><p>Any workload generating a large flow of data (a_ _stream) that needs to be processed in real-time is well-suited for stream processing. A stream is an infinite sequence of messages that are generated and sent continuously.</p><p>Stream processing architectures do have their challenges. The first is performance, as the application must handle the load of incoming data streams. Other challenges include order and logic, as we have to determine how our application should process the input stream.</p><p>Finally, stream processing is real-time. While this may be what we want in most cases, we might also have a batch-processing requirement.</p><h3 id=message-brokers>Message Brokers</h3><p>Mapping both technologies with each other immediately introduces another component: the message broker or message bus. A message broker is an interface between the message’s originator — a producer or publisher — and the destination handling system — a receiver or consumer, sometimes called a subscriber. It handles the message queue.</p><p>However, message brokers can combine several queues, providing scalability and high availability. Apache Kafka is one example of a message broker system.</p><p>Brokers are sometimes considered the more intelligent part of the solution stack. They’re typically responsible for message persistence and replication. So, if a message queue fails, the broker recognizes this and sends the incoming flow of messages to another queue. Since the message broker manages the communication between the producer and the consumer, neither component experiences downtime nor interruptions in message handling.</p><p>To address one of the message queue challenges, the broker can also recognize the message arrival order and how to process them.</p><h3 id=message-queue-versus-streaming-architecture>Message Queue Versus Streaming Architecture</h3><p>Performance is critical in a modern microservices architecture. So, we need to make sure we’re choosing an architecture that benefits us the most.</p><p>A message queue is asynchronous since messages move into a queue, waiting to be picked up. The receiving component may need to poll the message queue to find out if there are any new messages.</p><p>In contrast, an application should process a continuous stream of messages as they’re generated, using an active, ongoing process. Event-driven processing or event-based architecture often accomplishes this.</p><p>The magic keyword in event-based architecture is “trigger.” Whenever some event occurs, another process kicks off.</p><p>This trigger could move something to a queue, a stand-alone activity, like saving the camera image to storage or validating credit card details with the credit card company. However, the event-based architecture can also work in a more significant stream, like checking for a robbery via hundreds of surveillance cameras writing to storage or validating thousands of payment transactions to detect fraud. In these cases, the architecture moves data to a stream and performs real-time analytics.</p><p>Message queues and streaming are both valid solutions for event-based architectures. Deciding which is best depends on the nature of the application workload and solution and the foreseeable outcome. For example, it would be acceptable to use a message queue for a stand-alone credit card validation. However, it wouldn’t be a viable architecture for payment transaction fraud detection.</p><p>Let’s compare the benefits of message queues and stream processing.</p><table><thead><tr><th style=text-align:left>Message queue</th><th style=text-align:left>Stream</th></tr></thead><tbody><tr><td style=text-align:left>Controls data volumes</td><td style=text-align:left>Handles real-time data generation</td></tr><tr><td style=text-align:left>Enables batch processing</td><td style=text-align:left>Allows real-time analytics</td></tr><tr><td style=text-align:left>Routing logic based on message brokers</td><td style=text-align:left>Multiple subscribers to control message flow traffic</td></tr><tr><td style=text-align:left>Asynchronous data processing</td><td style=text-align:left>Synchronous, continuous data flow</td></tr></tbody></table><h2 id=message-queue-and-streaming-solutions>Message Queue and Streaming Solutions</h2><p>There are many message queue and streaming solutions available. Let’s take a closer look at Apache Pulsar as an example.</p><p>Yahoo originally developed Apache Pulsar to enable various data flows within their cloud environment. Now, it’s open-sourced through the Apache Software Foundation.</p><p>Developers find it to be a robust and scalable messaging and streaming platform. We can deploy Pulsar on bare metal as physical or virtual machines, run it inside Docker containers, or scale it within Kubernetes clusters, depending on the organization or workload application’s needs.</p><p>Pulsar’s core is the publisher-subscriber (pub/sub) architecture. Producers create messages and publish them to topics. Consumers subscribe to topics to recognize the specific messages they must handle.</p><p><img src=https://user-images.githubusercontent.com/16946028/159680446-ad072a9f-3f0e-4da8-9b4d-aaeac472f891.PNG alt="Message queue and streaming solutions"></p><p>Each Pulsar instance contains one or more Pulsar clusters. The Pulsar clusters are message brokers, delivering messages from the producers to the consumers. Pulsar can replicate data across clusters to optimize performance and scale.</p><p>Apart from the message brokers, Pulsar also relies on Apache BookKeeper as a temporary message store and Apache ZooKeeper to orchestrate and coordinate across Pulsar clusters. <a href=https://pulsar.apache.org/docs/en/concepts-architecture-overview/ target=_blank>Pulsar’s architecture</a> provides everything we need to handle traditional message queues or resource-intensive continuous streams.</p><p>Let’s say our application needs direct communication between the producer and consumer. A message queue can manage the messages that the application can’t process immediately. Once the consumer acknowledges the message, it is removed from the queue. Payment transactions, food ordering apps, and e-commerce benefit from a Pulsar message queue architecture.</p><p>Or, perhaps our application workload involves producers generating a vast amount of data that we need to analyze in real-time, like IoT or payment fraud detection. Pulsar can integrate this streaming analytics processing as well. Pulsar’s stream processing unit, Pulsar Functions, takes ownership of the analysis and handles the messages routing across the producer and consumer.</p><p>In the past, developers needed to use different solutions for messaging and streams. Pulsar’s most significant benefit is combining traditional message queueing with stream processing within the same architecture. This ability simplifies the architecture, reducing the burden of maintaining skills across different platforms and solutions.</p><h2 id=conclusion>Conclusion</h2><p>E-commerce order processing benefits from message queueing, while streaming offers real-time data analytics on a continuous influx of data, such as IoT or global payment transactions. Each solution has its challenges and benefits.</p><p>Your decision on which to use depends on your specific needs. If your application workload needs queuing and streaming, you may consider a highly-available, scalable, robust all-in-one solution like Pulsar.</p><p>Now that you understand the differences between these seemingly-similar solutions, you’re better equipped to decide which is best for your application.</p></article><div class="row border border-primary rounded"><div class="col p-2"><h3>You might also like...</h3><div class=row><div class="col text-center p-2"><div class=pt-2><a href=/articles/pulsar-queuing-and-streaming-an-all-in-one-messaging-system/>Pulsar: Queuing and Streaming - An All in One Messaging System</a></div><div class=pt-2>I would also like to focus this reading on what is Pulsar and how it works under its own merits …</div></div><div class="col text-center p-2"><div class=pt-2><a href=/articles/building-a-high-available-messaging-system-a-step-by-step-cookbook/>Pulsar: Building a High Available Messaging System - A Step by Step CookBook</a></div><div class=pt-2>This guide will walk you step by step to deploy a Pulsar instance with one cluster but prepared …</div></div><div class="col text-center p-2"><div class=pt-2><a href=/videos/apache-pulsar-transactions-api-deep-dives/>Apache Pulsar Transactions API Deep Dives</a></div><div class=pt-2>Transactions are an API in Apache Pulsar that enables atomic operations among pulsar consumers and …</div></div></div></div></div><br><div id=disqus_thread></div><script type=text/javascript>(function(){if(window.location.hostname=="localhost")return;var t,e=document.createElement("script");e.type="text/javascript",e.async=!0,t="pulsar-neighborhood",e.src="//"+t+".disqus.com/embed.js",(document.getElementsByTagName("head")[0]||document.getElementsByTagName("body")[0]).appendChild(e)})()</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript></div></div><div class="col-0 col-md-2"><nav class="navbar navbar-light mb-3"><div class=row><div class=col-12><h4>In this article</h4></div><div class="col-12 border-left border-primary pr-0"><nav id=TableOfContents><ul><li><a href=#differences-between-message-queues-and-streaming>Differences Between Message Queues and Streaming</a><ul><li><a href=#message-queues>Message Queues</a></li><li><a href=#streaming>Streaming</a></li><li><a href=#message-brokers>Message Brokers</a></li><li><a href=#message-queue-versus-streaming-architecture>Message Queue Versus Streaming Architecture</a></li></ul></li><li><a href=#message-queue-and-streaming-solutions>Message Queue and Streaming Solutions</a></li><li><a href=#conclusion>Conclusion</a></li></ul></nav></div></div></nav></div></div></div></div><div class="sub-footer m-5"><div class=row><div class="col-12 text-center"><a href=https://github.com/pulsar-neighborhood/pulsar-neighborhood.github.io/blob/main/content/articles/Understanding-The-Differences-Between-Message-Queues-And-Streaming.md target=_blank>Improve this page</a></div></div><div class="col-8 offset-2"><hr class="bg-primary text-primary"></div><div class="sub-footer-inner mt-2"><div><div class=mb-1>Pulsar Neighborhood</div><div><ul><li style=width:40px><a href=https://github.com/pulsar-neighborhood target=_blank><img src=/svg/github-brands.svg title="Pulsar Neighborhood on GitHub" class=img-fluid></a></li><li class="ml-3 mr-1" style=width:40px><a href=https://twitter.com/pulsar_neighbor target=_blank><img src=/svg/twitter-brands.svg title="Pulsar Neighborhood on Twitter" class=img-fluid></a></li><li style=width:40px><a href=https://www.youtube.com/c/ApachePulsarNeighborhood target=_blank><img src=/svg/youtube-brands.svg title="Pulsar Neighborhood on YouTube" class=img-fluid></a></li><li style=width:40px><a href=https://datastudio.google.com/reporting/743d9f31-c80f-4e60-b520-730631d3c250 target=_blank><img src=/png/google-analytics.png title="Pulsar Neighborhood analytics" class=img-fluid></a></li></ul></div></div><div class=p-5></div><div><div class=mb-1>Apache Pulsar</div><div><ul><li style=width:40px><a href=https://pulsar.apache.org target=_blank><img src=/png/pulsar-icon.jpg title="Apache Pulsar project home" class=img-fluid></a></li><li class="ml-3 mr-1" style=width:40px><a href=https://github.com/apache-pulsar target=_blank><img src=/svg/github-brands.svg title="Apache Pulsar on GitHub" class=img-fluid></a></li><li class=mr-1 style=width:40px><a href=https://twitter.com/Apache_Pulsar target=_blank><img src=/svg/twitter-brands.svg title="Apache Pulsar on Twitter" class=img-fluid></a></li><li class=mr-1 style=width:30px><a href=https://stackoverflow.com/questions/tagged/apache-pulsar target=_blank><img src=/svg/stack-overflow-brands.svg title="Apache Pulsar on Stackoverflow" class=img-fluid></a></li><li style=width:40px><a href=https://apache-pulsar.slack.com target=_blank><img src=/svg/slack-brands.svg title="Apache Pulsar slack channel" class=img-fluid></a></li></ul></div></div></div><div class="row text-center mb-3"><div class=col-12><a class="btn btn-info" href=https://pulsar.apache.org/community/ target=_blank>Join the Pulsar community</a></div></div><div class="row text-center"><div class="col-12 text-center"><div><a href=https://github.com/pulsar-neighborhood/pulsar-neighborhood.github.io/issues/new/choose>Contact Us</a></div></div></div></div><script type=text/javascript src=/js/scripts.min.8efe3e711319c2d0a300a084134e3f3bedcb60dce21f1e0ef12767f654242b44.js></script>
<script src=https://ajax.googleapis.com/ajax/libs/jquery/3.6.0/jquery.min.js></script>
<script src=https://cdn.jsdelivr.net/npm/bootstrap@4.6.1/dist/js/bootstrap.bundle.min.js integrity=sha384-fQybjgWLrvvRgtW6bFlB7jaZrFsaBXjsOMm/tB9LTS58ONXgqbR9W8oWht/amnpF crossorigin=anonymous></script>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-8S9SD43SBH"></script>
<script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-8S9SD43SBH")</script></body></html>